[{"title":"JavaScript 数据结构--数组","date":"2021-07-25T13:40:27.000Z","path":"2021/07/25/javascript-array/","text":"数组是计算机编程世界里最常见的数据结构。任何一种编程语言都包含数组。它是编程语言中的内建模型，通常效率很高，可以满足不同需求的数据存储。 一、JavaScript 中的数组数组的标准定义是：一个存储元素的线性集合（collection），元素可以通过索引来进行存取操作，所以通常是数字，用来计算元素之间存储位置的偏移量。 通俗地讲，数组是一种线性表数据结构，它使用一组连续的内存空间，来存储一组具有相同类型的数据。但是在 JavaScript 中，数组中可以保存不同类型的值（为遵守最佳实践，一般不建议这么做）。 然而 JavaScript 中的数组，严格来说应该称作对象，是一种特殊的对象，索引是它的属性，可以是整数，但是由于 JavaScript 中对象的属性名必须为字符串，所以这些索引在内部由数字类型被转换为字符串类型。 二、使用数组2.1 创建和初始化数组你可以通过 [] 操作符来声明一个数组变量： var nums = []; // 长度为 0 当然了，你也可以在声明数组时直接放入一些元素： var nums = [1,2,3,4]; // 长度为 4 另外，你还可以通过构造函数来创建它： var nums = new Array(1,2,3,4,5); 同样，你也可以用它来创建一个长度为 10，元素为 0 的数组： var arr = new Array(10).fill(0); 最后，我们可以通过 Array.isArray() 来判断一个对象是否是数组: var a = 1; console.log(Array.isArray(a)); // false console.log(Array.isArray(nums)); // true 2.2 添加和删除元素添加元素： push 方法: 把元素添加到数组的末尾； unshift 方法: 把元素插入到数组的首位； 删除元素： pop 方法：删除数组末尾的元素; shift 方法：删除数组首位的元素； slice 方法：删除相应位置和数量的元素，还可以通过第三个参数添加或替换元素。 Tips!!!: 在 JavaScript 中，数组是一个可以修改的对象。添加元素，它就会动态增长； 通过 push 和 pop 方法，可以用数组来模拟栈； 通过 unshift 和 shift 方法，可以用数组来模拟队列。 2.3 二维和多维数组JavaScript 只支持一维数组，但是可以通过数组嵌套数组的方式实现任一多维数组： var arrs = [[1,2],[3,4]] 2.4 JavaScript 数组的方法 方法名 描述 concat 连接 2 个或更多数组，并返回结果 every 对数组中每一个元素运行指定函数，如果该函数对每一项都返回true，则返回 true filter 对数组中每一个元素运行指定函数，返回该函数返回 true结果的项组成的数组 forEach 对数组中每一个元素运行指定函数，没有返回值 join 将所有的数组元素拼接成一个字符串 indexOf 返回第一个与给定参数相等的数组元素的索引，没有找到则返回-1 lastIndexOf 返回在数组中搜索到的与给定参数相等的元素的索引里最大的值 map 对数组中的每一项运行指定函数，返回每次函数调用的结果组成的数组 reverse 翻转数组 slice 传入索引值，将数组里对应范围内的元素作为新数组返回 some 对数组中的每一项运行指定函数，任一项返回true，则返回true sort 对数组中的元素进行排序 toString 将数组作为字符串返回 valueOf 类似 toString","categories":[{"name":"技术整理","slug":"技术整理","permalink":"https://iamtaoxin.com/categories/%E6%8A%80%E6%9C%AF%E6%95%B4%E7%90%86/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://iamtaoxin.com/tags/JavaScript/"}]},{"title":"尤雨溪自述：打造 Vue 3 背后的故事","date":"2020-05-30T00:38:53.000Z","path":"2020/05/30/making-vue-3/","text":"尤雨溪在今年年初 Vue 3 正式发布之前撰写了这篇长文，详述 Vue 3 的设计过程。前端之巅将全文翻译如下，希望能帮助你更好地了解 Vue 3 背后的故事。 在过去的一年中，Vue 团队一直都在开发 Vue.js 的下一个主要版本，我们希望能在今年上半年发布它（本文完成时这项工作尚在进行）。Vue 新版本的理念成型于 2018 年末，当时 Vue 2 的代码库已经有两岁半了。比起通用软件的生命周期来这好像也没那么久，但在这段时期，前端世界已经今昔非比了。 在我们更新（和重写）Vue 的主要版本时，主要考虑两点因素：首先是新的 JavaScript 语言特性在主流浏览器中的受支持水平；其次是当前代码库中随时间推移而逐渐暴露出来的一些设计和架构问题。 一、为什么重写利用新的语言特性随着 ES2015 标准的落地，JavaScript（以前被称为 ECMAScript，缩写为 ES）获得了诸多重大改进，同时主流浏览器也终于开始对这些新特性提供良好的支持了。其中的一些特性使我们能够大幅提升 Vue 的能力。 这里面最值得一提的就是 Proxy ，它为框架提供了拦截针对对象的操作的能力。Vue 的一项核心特性就是监听用户定义状态的变化，并响应式更新 DOM。Vue 2 是通过替换状态对象属性的 getter 和 setter 来实现这种响应能力的。转向 Proxy 后，我们就能解决 Vue 当下存在的诸多局限（比如无法检测新增属性等），还能提供更好的性能。 但 Proxy 是一个原生的语言特性，无法在老式浏览器中提供完整的 polyfill。为此我们需要改动新版框架的浏览器支持范围——这是一项破坏性变更，只有新的主要版本才能实现。 二、解决架构问题 在现有代码库上修复这些问题需要大量高风险的重构工作，几乎等同于重写了。 在维护 Vue 2 的过程中，我们积累的很多问题受限于现有的架构是很难解决的。例如，模板编译器的写法使我们很难实现良好的源映射支持。另外，虽然 Vue 2 技术上支持构建以非 DOM 平台为目标的高级渲染器，但为了实现这一支持，我们需要 fork 代码库，还得复制一大堆代码。在现有代码库上修复这些问题需要大量高风险的重构工作，几乎已经等同于重写了。 同时，我们在很多内部模块与看起来无处可去的零散代码之间生成了很多隐藏的耦合关系，结果积累了不少技术债。现在我们很难单独理解代码库中某一部分的含义，而且我们也注意到贡献者们很少有信心做出突破性的更改。通过重写，我们得以基于这些问题重新思考代码的组织方式。 三、早期的原型阶段我们是从 2018 年末开始创建 Vue 3 的原型的，主要目标是验证针对上述问题的解决方案。在这一阶段，我们主要是为后续的开发工作打下牢固的基础。 转向 TypeScriptVue 2 最初是用纯粹的 ES 编写的。原型阶段开始后不久，我们意识到对于这么大规模的项目来说，类型系统会非常有用。类型检查可以大幅降低在重构中引入意外 bug 的几率，也能提升贡献者在做出突破性更改时的信心。我们采用了 Facebook 的 Flow 类型检查器，因为它可以渐进添加到一个现有的纯 ES 项目中。Flow 起了一定作用，但我们的收益不及预期；特别是它的重大更改太多了，升级起来相当痛苦。它对集成开发环境的支持也不如 TypeScript 与 VS Code 的深度集成水平。 我们还注意到越来越多的用户在结合使用 Vue 和 TypeScript。为了支持他们的使用场景，我们需要在源码之外单独编写和维护一套 TypeScript 声明，其使用了另一套类型系统。转向 TypeScript 后，我们就能自动生成声明文件，降低维护成本。 解耦内部包我们还采用了一个单体仓库方案，其中框架是由众多内部包组成的，每个包都有自己独立的 API、类型定义和测试用例。我们想让各个模块间的依赖关系更明显，让开发人员更容易阅读、理解和修改所有这些依赖项。这是我们降低项目贡献门槛，提升其长期可维护性的关键举措。 制定 RFC 流程2018 年末，我们有了一个带有新的响应系统和虚拟 DOM 渲染器的原型。我们验证了计划中的内部架构优化，但只是粗略起草了面向外部的 API 更改想法。现在该将这些想法转变为具体的设计了。 我们知道这一步要在早期谨慎进行。Vue 的广泛流行意味着重大更改可能会给用户带来巨大的迁移成本，还可能让生态碎片化。为了让用户对重大更改提交反馈，我们在 2019 年初制定了一套 RFC（征求意见）流程。所有 RFC 都有一个模板，包括动机、设计细节、权衡以及采用策略等内容。这套流程的实现形式，是在一个 Github 仓库上将提案提交成拉取请求，这样自然就可以在评论中讨论提案了。 结果表明这个 RFC 流程非常有用。作为一个思维框架，它强制我们全面考虑一个潜在更改的所有层面，并让整个社区可以参与到设计过程中，并提交经过充分思考的特性需求。 四、更快，更小 前端框架的性能至关重要。 前端框架的性能至关重要。尽管 Vue 2 已经提供了颇具竞争力的性能表现，但这次重写让我们有机会试验新的渲染策略来进一步提升性能。 突破虚拟 DOM 的瓶颈Vue 有一套独特的渲染策略：它提供了一个类 HTML 的模板语法，但将模板编译成了一个返回虚拟 DOM 树的渲染函数。框架会递归遍历两个虚拟 DOM 树，对比每个节点的所有属性来判断该更新 DOM 的哪些部分。这种相对暴力的算法一般还是很快的，这要感谢现代 JS 引擎实现的那么多高级优化措施。但是更新过程还是会涉及很多不必要的 CPU 工作。当你的模板存在大量静态内容，却只有少量动态绑定时，更新的效率就会显得尤为低下——还是要递归遍历整个虚拟 DOM 树，才能找出要更新的部分。 所幸模板编译这一步让我们可以对模板进行静态分析，并提取动态部分的信息。Vue 2 跳过了静态子树，在一定程度上做到了这一点；但是由于过度简化的编译器架构，更高级的优化就很难实现了。在 Vue 3 中我们重写了编译器，加入了一个合适的 AST transform 管道，让我们能以 transform 插件的形式进行编译时优化。 现在有了新的架构，我们想要找到一个尽可能减少额外开销的渲染策略。一个选项是抛弃虚拟 DOM 并直接生成命令式 DOM 操作，但这会失去直接编写虚拟 DOM 渲染函数的能力，我们发现这是对于高级用户和库作者们非常有价值的能力。此外，这也会是一个影响巨大的重大更改。 接下来的选项就是摆脱不必要的虚拟 DOM 树遍历和属性对比，这也是更新过程中性能开销最大的部分。为此，编译器和运行时需要协同工作：编译器分析模板，生成带有优化线索的代码，而运行时获取线索并选择最快路径。这里有三大优化工作： 首先，在树级别，我们注意到没有动态调整节点结构的模板指令（如 v-if 和 v-for）时，节点的结构完全保持静态。如果我们将模板根据这些结构化指令拆分为一些嵌套 “ 块 “，每一个块中的节点结构也会保持静态。当我们更新一个块中的节点时，就不必再递归遍历整个树了——块内的动态绑定可以在一个平面数组里追踪。这一优化极大减少了需要遍历的树的数量，规避了大部分虚拟 DOM 树开销。 其次，编译器会激进检测模板中的静态节点、子树甚至数据对象，并在生成的代码中将它们提取到渲染函数之外。这就可以避免在每次渲染时重新创建这些对象，大幅减少了内存占用，并减少了垃圾收集的频率。 最后，在元素级别，编译器会为每一个有动态绑定的元素，根据其需要进行的更新类型生成一个优化标志。比如说一个元素有一个动态的 class 绑定和一些静态属性，它会获得一个标志，表示这里只需要进行 class 检查。运行时会获取这些标志，然后选择最快的路径。 CPU 时间：是指 JavaScript 运算所消耗的时间，不包括浏览器 DOM 操作所用的时间。 结合这些优化，我们的渲染更新速度获得了显著改进，在某些场景下 Vue 3 的 CPU 时间仅为 Vue 2 的十分之一不到。 缩小包体积框架的大小也会影响其性能。这是 Web 应用程序特有的现象，因为资产需要在线下载，而应用需要等到浏览器解析完必要的 JavaScript 代码后才能开始交互。单页面应用程序在这方面的矛盾尤为明显。尽管 Vue 一直以来都是相对轻量级的框架——Vue 2 的运行时大小为 23KB（gzip 压缩后），我们还是注意到了两个问题： 首先，不是所有人都需要框架的全部功能。例如，从来不需要过渡特性的应用还是需要下载和解析相关代码。 另外，我们在不断给框架增加新特性，框架也在不断变大，没有止境。这样我们在权衡新特性的利弊时，就得非常在意包大小这个权重。结果，我们会倾向于只加入那些大多数用户都会用到的特性。 理想状态下，用户可以在构建时去掉框架中自己不需要的特性（也就是 “ 摇树优化 “），只保留自己用到的特性。这样我们在添加只有部分用户会用到的特性时，并不会给其他用户增添应用体积的负担。 在 Vue 3 中，我们把大多数全局 API 和内部 helper 移到了 ES 模块导出中，从而实现了这个目标。这样现代的打包器就可以静态分析模块依赖项，并去掉与未使用导出相关的代码。模板编译器也会生成适合摇树优化的代码，只会对模板确实用到的特性导入 helper。 框架的有些部分是永远无法摇树优化的，因为它们对于所有应用类型来说都很重要。我们将这部分无法舍弃的代码的体积称作基线大小。虽然 Vue 3 增加了很多新特性，但其基线大小只有大约 10KB（gzip 后），不到 Vue 2 的一半。 五、满足扩展需求我们还想改善 Vue 应对大规模应用程序的能力。我们最初设计 Vue 时主要想的是降低入门门槛并平滑学习曲线。但随着 Vue 愈加流行，我们也看到了越来越多的项目需求随着时间推移不断扩大，后期甚至包含数以百计的模块，需要几十名开发人员来维护。对于这种类型的项目，TypeScript 这样的类型系统和可以提供组织清晰、易于复用的代码的能力是必不可少的，但 Vue 2 在这些方面的支持水平不甚理想。 在 Vue 3 的早期设计阶段，我们尝试内置对使用 class 编写组件的支持，从而更好地整合 TypeScript。这里的问题在于，为了让 class 可用而需要的很多语言特性（例如 class fields 和 decorators）都还处在提案阶段，有可能在正式版中出现变化。随之而来的复杂性和不确定性让我们开始质疑 Class API 是否真的合适，因为它只能改善一点 TypeScript 的整合能力而已。 于是我们决定探索其他途径来解决扩展问题。受到 React Hooks 的启发，我们想到了暴露底层的响应式和组件生命周期的 API，从而提供一种更灵活地编写组件逻辑的方式，也就是 Composition API 。Composition API 不再需要用一个长长的配置列表定义组件，它允许用户自由定义、组合和重用组件逻辑，就像写函数一样，同时还能提供完善的 TypeScript 支持。 我们非常喜欢这个想法。尽管 Composition API 是为解决特定类型的问题设计的，但也能用在单纯的组件开发中。在提案的初稿中我们有些忘乎所以，暗示我们可能会在未来的版本中用 Composition API 替换掉当前的 Options API。这引起了社区成员的极大反弹，给我们上了重要的一课，让我们认识到了与社区沟通长期计划和发展方向，以及理解用户需求的重要性。在听取社区反馈之后，我们完全重做了提案，确认 Composition API 只是锦上添花，是 Options API 的补充。新版提案的反馈要正面许多，我们还收到了很多建设性的意见。 六、把握平衡 开发人员的多样性意味着使用场景的多样性。 如今有超过一百万的开发人员在使用 Vue，其中有只懂一点 HTML/CSS 的新手，从 jQuery 一路走来的专家，从其他框架迁移过来的老鸟，在寻找前端解决方案的后端工程师，还有负责设计大规模软件的架构师。开发人员的多样性意味着使用场景的多样性：有的开发人员可能想要提升旧项目的交互体验，另一些人可能想要快速开发低成本的一次性项目；架构师可能要应对规模巨大的长期项目，以及项目生命周期内的开发团队成员变动。 Vue 的设计在不断根据这些需求变化和发展，我们也设法从诸多权衡中找到平衡点。Vue 的口号“渐进式框架”，背后就是这个过程中形成的分层 API 设计。新手可以通过 CDN script、基于 HTML 的模板以及直观的 Options API 顺利学习入门。而专家可以通过全功能的 CLI、渲染函数以及 Composition API 来处理复杂需求。 要实现我们的愿景还有很多工作要做，其中最重要的就是更新支持库、文档和工具，以保证平滑的迁移。我们会在未来的几个月中继续努力，而且我们迫不及待想要看到社区能用 Vue 3 创造怎样的精彩了。 作者介绍尤雨溪是 Vue.js 框架的创建者和项目领导，也是一位独立开源开发者。 原文链接：https://increment.com/frontend/making-vue-3/ 译文链接：https://www.infoq.cn/article/rTS3OweiTlA8OldIidBz","categories":[{"name":"技术搬运","slug":"技术搬运","permalink":"https://iamtaoxin.com/categories/%E6%8A%80%E6%9C%AF%E6%90%AC%E8%BF%90/"}],"tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://iamtaoxin.com/tags/Vue-js/"}]},{"title":"喜欢一个人，就多让 Ta 微笑","date":"2020-04-06T13:05:10.000Z","path":"2020/04/06/luck-01/","text":"我们终其一生，不就是为了遇见那个最值得的人么。 越长大，越孤单，越很少能感受到真正的快乐，更多时候是在带着面具生活着，。微笑可能只是一种纯粹礼貌的表情，不带任何心情，那些单纯的快乐慢慢变成了奢望。 生活本就没有那么多快乐，生活本就需要我们去创造更多的快乐。 如果真正喜欢一个人，就多让 ta 微笑。","categories":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"https://iamtaoxin.com/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"}],"tags":[{"name":"人间值得","slug":"人间值得","permalink":"https://iamtaoxin.com/tags/%E4%BA%BA%E9%97%B4%E5%80%BC%E5%BE%97/"}]},{"title":"Chrome80 跨域名登录失效的问题","date":"2020-03-23T13:19:15.000Z","path":"2020/03/23/chrome-80/","text":"Chrome 80 版本在跨域名登录时存在问题，可能会使页面陷入死循环的状态，导致用户无法正常登录。这主要是由于这个版本中，Chrome 的策略有所更新。 在旧版浏览器，如果 SameSite 属性没有设置，或者没有得到运行浏览器的支持，那么它的行为等同于 None，Cookies 会被包含在任何请求中——包括跨站请求。 但是，在 Chrome 80+ 版本中，SameSite 的默认属性是 SameSite=Lax。换句话说，当 Cookie 没有设置 SameSite 属性时，将会视作 SameSite 属性被设置为Lax 。如果想要指定 Cookies 在同站、跨站请求都被发送，那么需要明确指定 SameSite 为 None。具有 SameSite=None 的 Cookie 也必须标记为安全并通过 HTTPS 传送。 在 Chrome 88 之前，您将能够使用策略还原为旧版 Cookie 行为。您可以使用 LegacySameSiteCookieBehaviorEnabledForDomainList 指定受信任的域，也可以使用 LegacySameSiteCookieBehaviorEnabled 控制全局默认值。有关更多详细信息，请访问 Cookie旧版SameSite政策：https://www.chromium.org/administrators/policy-list-3/cookie-legacy-samesite-policies。 以上更新可能对以下功能造成影响： 跨域名登陆失效 jsonp 获取数据失效 iframe 嵌套的页面打不开或异常 部分客户端未改造导致各种数据获取异常 建议大家针对上述更新对自己的站点功能在新版浏览器下做一些测试，以免影响功能正常使用。 你可以到 chrome://flags/ 开启 SameSite by default cookies、Cookies without SameSite must be secure 进行测试。","categories":[{"name":"技术整理","slug":"技术整理","permalink":"https://iamtaoxin.com/categories/%E6%8A%80%E6%9C%AF%E6%95%B4%E7%90%86/"}],"tags":[{"name":"踩过的坑","slug":"踩过的坑","permalink":"https://iamtaoxin.com/tags/%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/"}]},{"title":"Vue 的作用域插槽的用法","date":"2020-03-11T04:46:47.000Z","path":"2020/03/11/vue-slot/","text":"在某些场景下，需要让插槽中的内容能够访问子组件中才有的数据。 一、场景代码有一个带有如下模板的 &lt;list&gt; 组件： &lt;template> &lt;slot name=\"action\" v-bind:action=\"user\">&lt;/slot> &lt;/template> 页面代码如下： &lt;list> &lt;template v-slot:action=\"&#123; action &#125;\"> &lt;el-button size=\"mini\" icon=\"el-icon-view\" type=\"primary\" @click=\"handleEdit(action)\">&lt;/el-button> &lt;el-button size=\"mini\" icon=\"el-icon-delete-solid\" type=\"danger\" @click=\"handleRemove(action.id)\">&lt;/el-button> &lt;/template> &lt;/list> 从上面代码可以看出，为了让 action 在父级的插槽内容中可用，我将 user 作为 &lt;slot&gt; 元素的一个特性绑定到了组件上面。因此，绑定在 &lt;slot&gt; 上的特性被称为 插槽 prop。而且，在父级作用域中，我们可以给 v-lot 附带一个值（上面代码中便是 action ）来定义我们提供的插槽 prop 的名字。 观察上面代码，可以看出，这种写法是具名插槽，当然也可以使用默认插槽： &lt;list> &lt;template v-slot:default=\"&#123; action &#125;\"> &lt;el-button size=\"mini\" icon=\"el-icon-view\" type=\"primary\" @click=\"handleEdit(action)\">&lt;/el-button> &lt;el-button size=\"mini\" icon=\"el-icon-delete-solid\" type=\"danger\" @click=\"handleRemove(action.id)\">&lt;/el-button> &lt;/template> &lt;/list> 这种写法还可以更简单些，不带参数 v-slot 被假定对应默认插槽： &lt;list> &lt;template v-slot=\"&#123; action &#125;\"> &lt;el-button size=\"mini\" icon=\"el-icon-view\" type=\"primary\" @click=\"handleEdit(action)\">&lt;/el-button> &lt;el-button size=\"mini\" icon=\"el-icon-delete-solid\" type=\"danger\" @click=\"handleRemove(action.id)\">&lt;/el-button> &lt;/template> &lt;/list> 二、其他事项注意： 默认插槽的缩写语法 不能 和具名插槽混用，会导致作用域不明确； 如果出现多个插槽，须为_所有的 _插槽使用完整的基于 &lt;template&gt; 的语法。 另外：关于 Vue 的作用域插槽的详细描述，可查看官方文档：作用于插槽","categories":[{"name":"技术整理","slug":"技术整理","permalink":"https://iamtaoxin.com/categories/%E6%8A%80%E6%9C%AF%E6%95%B4%E7%90%86/"}],"tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://iamtaoxin.com/tags/Vue-js/"}]},{"title":"You Are Using the Runtime-Only Build of Vue Where the Template Compiler Is Not Available. Either Pre","date":"2020-03-07T13:13:45.000Z","path":"2020/03/07/vue-run-time/","text":"在 Vue 项目初始化时遇到了这样的问题： [Vue warn]: You are using the runtime-only build of Vue where the template compiler is not available. Either pre-compile the templates into render functions, or use the compiler-included build. 分析原因Vue 的代码有两种形式， compiler 模式 和 runtime 模式，默认为 runtime 模式，Vue 模块则指向 dist/vue.runtime.common.js 位置。 观察我的 main.js 代码，是这样的的，跟之前的写法大为不同： /_ eslint-disable no-new _/; new Vue(&#123; el: \"#app\", router, created() &#123;&#125;, components: &#123; App, &#125;, template: \"&lt;App/>\", &#125;); 这种形式是 compiler 模式，因此就会出现上面的错误。 解决办法 直接修改 main.js 代码 //runtime new Vue(&#123; router, store, render: (h) => h(App), &#125;).$mount(\"#app\"); 在 Vue cli 2.0 中没有出现这个为，是因为 2.0 中 有 webpack 的别名配置如下： resolve:&#123; alias:&#123; 'vue$': 'vue/dist/vue.esm.js' &#125; &#125; 也就是说， import Vue from &#39;vue&#39; 这行代码被解析为 import Vue from &#39;vue/dist/vue.esm.js&#39; , 因此直接指定了文件的位置，而没有使用 main 字段默认的文件位置。针对上面问题，也可以直接在 main.js 中修改引用 vue 的代码： import Vue from \"vue/dist/vue.esm.js\"; 修改 webpack 配置 在 Vue cli 3.0 中需要在 vue.config.js 文件里加上 webpack 的配置，具体代码如下： configureWebpack: &#123; resolve: &#123; alias: &#123; 'vue\\$': 'vue/dist/vue.esm.js' &#125; &#125;","categories":[{"name":"技术整理","slug":"技术整理","permalink":"https://iamtaoxin.com/categories/%E6%8A%80%E6%9C%AF%E6%95%B4%E7%90%86/"}],"tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://iamtaoxin.com/tags/Vue-js/"}]},{"title":"每日一笑","date":"2020-03-02T14:23:18.000Z","path":"2020/03/02/daily-laught/","text":"笑，是人的一种平和心态以及善良的内心表现，同时，也是体内安多芬分泌物增高的时候。人的心情处于正常状态时，在与他人交谈期间就会呈现为平和的心理作用并用微笑来展现人与人之间的善意交往。人们常说“笑一笑，十年少”，笑口常开，笑天下可笑之事。 段子多摘自网络，侵删。 2020-05-25 从前有一位老人，他在去世前给三个儿子出题以确实如何分割遗产，题目为用一金币买的东西充满房子。大儿子买了稻草，装了半屋，二儿子打开瓦斯，充满了房间，这时候小儿子端着一根点燃的蜡烛走进房间 2020-05-24 据说小孩能看见不干净的东西，大人们千万别不当回事！我一个朋友说他小时候经常看到两个小孩在他家空调上，就和父母说了这事，把他家里人吓的够呛，最后请来法师又请来半仙一阵忙活，可父母再问孩子，他还是能看见那俩小孩。后来因为这事他们家把房子卖了，搬到了另一个城市，连家具家电都不要了，直到他长大后…他爹才知道那两个小孩是海尔兄弟…差点没把他打死… 2020-05-23 网上买了个东西，想着捉弄一下快递小哥，收件人写的皇上，终于来了，对着快递小哥等他说：“皇上，你的快递。”想不到的是他问：“拿谁的快递？”我只能说：“拿皇上的。”快递小哥给我来了句：“哦～公公好年轻啊！”? 2020-05-22 爷爷退休了，报名上了老年大学， 正读一年级的孙子好奇地问：“爷爷，你还读书啊?” 爷爷说：“我读书有什么不好吗?” 孙子说：“好是好，就是万一你学校通知开家长会，那你怎么办呢?”.. .. .. 见过操心的没见过这么操心的 ！ 2020-05-21 花心的男人，是台球，一个杆可以进好几个洞。顾家的好男人，是高尔夫球，一个杆只进一个洞。而那些单身的屌丝们，是乒乓球，很黄，却没有洞可以进。 2020-05-20 今天是 520，我想说： 2020-05-19 有个贼偷水果被巡逻队抓，要关起来。那贼还理直气壮的说：不就偷了 20 斤山竹，至于关起来吗? 巡逻队不慌不忙的说：以前有个猴就偷了一个桃，被关了 500 年。 2020-05-18 2020-05-17 当年，和她赌气分手，昨天她出嫁，我偷偷的开车混在迎亲的车队后面，没开多远，收到她短信:“你不是说这辈子都不想见我吗，为什么要跟在车队后面？” 我回复:“你怎么知道我在车队后面，你还关注我？” 不一会收到她回复:“不是我关注你，是你的拖拉机声音太大！” 2020-05-16 2020-05-15 2020-05-14 2020-05-13 我爸妈都是特别不负责任的人，很久以前他们借别人钱的时候许下承诺：“借你的钱我们通通会还你。” 然后他们生下我取名叫“通通”。 2020-05-12 白衬衣袖口容易发黄，一般的洗衣精很难洗掉，不少人为此感到头疼，其实，不妨在洗的时候，吃点头痛药，就没那么头疼了。 2020-05-11 “爸爸，为什么我哥叫解放呢？”“咱们家有个传统，孩子一出生，出门看见啥就叫啥，生了你哥，出门看见了辆解放车，就叫解放，你姐呢，出门下雪了，就叫白雪，知道了吗狗屎？” 2020-05-10 小猪佩奇昨晚做了个梦，梦到自己长大以后成为了一个水手，妈妈说梦境跟现实都是相反的，于是佩琪长大后成了火腿。 2020-05-09 同事儿子会吹笛子和口琴，有一次来我家里玩，对我侄子说：你会吹笛子吗？侄子摇摇头。又说：你会吹口琴吗？侄子又摇摇头。然后问：那你会吹什么？侄子不好意思地说：我会吹空调！ 2020-05-08我哥问我妈：“当年家里那么穷，你干嘛还要生下弟弟？” 我妈说：“当年看你个子矮，怕你今后受欺负没人帮你报仇，所以才生下老二。” 我哥感动的说：“妈，这想法谁告诉你的？” 妈说：“看水浒传呀，武大郎要不是有个兄弟，死的多冤呀！” 2020-05-07 听说睡觉时把手机放在枕头边上会有辐射，对身体不好，于是睡觉时果断把枕头丢了。 2020-05-06 当年备战高考，晚上挑灯夜战，父亲走进我的房间说：注意劳逸结合，特别要保护好视力，千万别近视了！免得以后做泥瓦匠的时候看不到吊线，砖墙砌得不标准，老板要扣钱的！毕竟依你的成绩，上大学是不现实的。 2020-05-05 黄鼠狼在养鸡场山崖边立了块碑,写道:“不勇敢地飞下去,你怎么知道自己原来是一只搏击长空的鹰?!” 从此以后,黄鼠狼每天都能在崖底吃到那些摔死的鸡! 2020-05-04 我为了研究女生洗澡喜欢用什么牌子的沐浴露，找了 100 个人，结果她们的回答惊人的一致：你 TM 是怎么进来的。 2020-05-03 酝酿了很久，我辗转找到一个我中学暗恋的女生的电话，给她发了一条短信：如果只有一碗粥，你先喝半碗，剩下的半碗，我放在怀里给你保温……几分钟后，她回了一条短信:你愿意做我孩子的父亲吗？ 2020-05-02 单位组织体检,护士说领导心率一直不正常,遂请主任医师复检，复查后，主任和蔼地对护士说:以后把胸前的扣子扣好，可以提高工作效率。 2020-05-01 老夫妇去拍照，摄影师问：“大爷，您是要侧光，逆光，还是全光？”，大爷腼腆的说：“我是无所谓，能不能给你大妈留条裤衩？” 2020-04-30 小保姆嗓门特别大，主人叮嘱，今晚来的都是有身份的人，说话务必小声一点。吃完饭，主人客人玩牌，小保姆收拾完想早点休息，于是凑近男主人耳边轻声道：“那我先睡了哈。” 2020-04-29 2020-04-28 甲女：“你的未婚夫知道你的年龄吗？”乙女：“是的，他知道一部分。” 2020-04-27 一次坐公交，一位漂亮 MM 上了车，掏出了卡来刷卡，只听刷卡机回复：滴老人卡！全车人冻住，皆而望她。 她一脸黑线说：看什么，天山童老，没见过啊？一大爷起身，说：来，大娘，您坐这儿！ 2020-04-26 2020-04-25 2020-04-24 2020-04-23 看到姑姑在化妆，小侄女跑过来：“姑姑，我也要化妆。”“小丫头，你化什么妆？”“姑姑，我们班上有个男孩……”“瞧不出来啊，才上一年级，就有男朋友了？是不是想好看点，让他更喜欢你？”“不，他太讨厌，我要像你这样化个妆，吓死他！”“滚……” 2020-04-22 哥们：咱们关系怎么样？我：很铁！哥们：那好，既然这样，我跟你借钱的话你愿意借多少？我：60 块。哥们：靠，都很铁的关系你才借 60？我：对啊，废铁一斤 5 毛，你 120 斤。哥们：….. 2020-04-21 爸爸：“怎么搞的，大白天还开着灯？”儿子：“这是你早晨上班前忘记关了。”爸爸：“你发现了，为什么不关上？”儿子：“你不是经常教育我要用事实说服人吗？” 2020-04-20 前两天，老师打电话说我儿子考试语文９８分数学１７分，孩子偏科太严重了，人无压力轻飘飘，我给他好一顿胖揍还别说，这次考试就好多了，语文数学都１７分。 2020-04-19 今天和老妈去吃酒席，去之前老妈教我，出去嘴要甜一点，说看见别人小孩长得还过去的，就要夸奖人家长得好漂亮，实在看着丑的就夸奖别人长得好高，结果，吃个饭已经有好多人夸我长得高了。 2020-04-18 刚才结果外卖小哥哥手里的外卖，我说“辛苦啦，快多年了还得送外卖”，小哥笑笑和我说，“您也辛苦啦，快过年了还得吃外卖”。 2020-04-17 2020-04-16 小孩把妓院养的鹦鹉偷回家，一进门，鹦鹉便叫：搬家啦！看见他妈妈又叫：老板也换啦！看见他姐姐又叫：小姐也换了！看见他爸爸又叫：我 cao 还是老客！ 2020-04-15 去年，哥们终于做出了痛苦的决择，放弃了那个追了三年，为她买了三年早餐还被嫌弃了三年的女神。。。。上月，我突然接到了哥们和他女神要结婚的消息，细细才知道是女孩主动打电话给他的，原因是早晨起床去买早点真的很难受很难受。。。。 2020-04-14 早上起来去上班，两条腿痛的上下楼梯都得横着走，同事:“你怎么啦？路都不会走了！”我:“昨晚跟姐夫玩石头剪刀布，赢一次就深蹲 100 下，结果我连输两次，姐夫躺沙发上笑眯眯地看着我蹲了 200 下，累得我满身大汗，”同事:“你没赢为什么要蹲？” 2020-04-13 周末逛街买了瓶可乐，发现一老婆婆紧跟着我，于是转身问她：“干什么？老奶奶。”她说：“我要你手上的空瓶。”原来如此，于是我把空瓶给了她，谁知走了一段路发现她还跟着，纳闷地问她：“瓶子不是给你了吗？还有事？”谁知她说：“这天那么热，我就不相信你不再买一瓶！” 2020-04-12 邻居是丑女，今天正在家中洗澡！突然丑女喊道：“老公，好象有人偷看我洗澡！”老公：“是吗？那你赶紧把窗户打开！”丑女大怒：“我疯啦？”老公解释道：“你让他看清楚，下次他再也不敢看了” 2020-04-11 某公厕内，A 君便秘，拉了好久都拉不出来，这时另一男子 B 君冲进来，刚蹲下就噼里啪啦的拉得好不畅快，A 君听到后说：“伙计，真羡慕你呀，拉得这么痛快” B 君说：“有啥好羡慕的，裤子还没脱呢…… 2020-04-10 哥们结婚，让我陪着买家具，我让他买那个高端上档次的大沙发，哥们死活嫌贵，好说歹说不同意。最后旁边一个阿姨对他说：“一看你的朋友就是过来人，沙发和床一样重要，你确定你结婚后每天都能睡在床上吗？”哥们意味深长地看了一眼我发黑级别的眼圈，大喝一声：“走！带我看看最贵的！ 2020-04-09 上个月跟老丈人去钓鱼，浮标下沉，一拉是条大鱼，我用力往上拉，结果没站稳，把年过六旬的老丈人撞进了河里。老丈人上岸后也没说什么，就说水有点凉！前几天我又去找老丈人：爸，钓鱼去吗？老丈人：我就一个女儿，财产早晚都是你们的，你别太急…… 2020-04-08 和男朋友一起走，喜欢手搂着他的腰，顺便扯着他的衣服。有一天散步中，他忽然说：“别扯我的衣服了好不好？”我不悦，说：“你和我说话就不能加个宝贝？”然后他说：“别扯我的宝贝衣服好不好？”我：“……” 2020-04-07 吃饭的时候，老婆教导儿子：“以后结了婚，一定要学会藏私房钱，你看你爸藏了我就找不着。” 我争辩道：“我从没藏过私房钱！ ” 老婆立马捅了一下我，说：“这句最重要，记着经常说！ ” 2020-04-06 小美在作文簿里写上长大后的愿望：一、我希望能有一个可爱的孩子；二、我还希望能有一个爱我的丈夫。结果，发现老师写了一句评语：“请注意先后顺序。” 2020-04-05 有个朋友第一次勤工俭学在公园里卖冰棍，不好意思吆喝；这时候突然有一人在那里大喊：“卖冰棍儿卖冰棍儿”。那朋友一听，心里可高兴了，就跟着喊：“我也是我也是”。 2020-04-04 一小孩给了我一百块钱，让我给他当家长。到了他班主任那里，我立马就跪下来了：老婆，你听我解释……” 2020-04-03 儿子哭闹着要买乐高，老婆被吵的不耐烦了：有本事你再哭一声，看我不揍你！我劝道：你昨天看了一篇文章，还跟我说对小孩不能那么简单粗暴！老婆听了，若有所思。她蹲了下来，温柔的对儿子说：不能哭哦，再哭妈妈会揍你的呦！ 2020-04-02 走到楼下，看到一男一女坐在草坪上谈恋爱，女的狂戳手机，男的无奈坐在旁边。我过去只说了一句“卧槽，有蛇！”那女的哇的一下就扑到男的怀里去了。我刚在心里默默道，学长只能帮你到这里了。谁料到那男的推开女孩，跑的比什么都快。 2020-04-01 隔壁女汉子好像终于意识到找个男盆友的重要性了，因为她的签名改成了：其实想说，有个男朋友还是蛮重要的，至少在家里水管爆裂的时候，可以给我递下扳手… 2020-03-31有一次急性肠胃炎去医院，痛的死去活来，我爸来看我，一脸焦急的跟我说，这医院怎么连一个 wifi 都连不上。 2020-03-30 一同学分不清“钓”跟“钩”，作文里有句话就变成了“鱼终于上钓了” 2020-03-29 2020-03-28 孩子问妈妈：“为什么蜡烛火苗一窜一窜的” 妈妈说：“因为这是精神小火 ” ​ 2020-03-27 你听过最孤独的话是什么？ 同学，作业就剩你没交了。 2020-03-26 2020-03-25 2020-03-24 2020-03-23 你听过最孤独的话是什么？ 同学，作业就剩你没交了。 2020-03-22 有个人想给自己孩子取名张三，最后取了张思睿 2020-03-21 初中的时候刚带隐形眼镜，回到家给奶奶说戴隐形眼镜了。奶奶问我什么是隐形眼镜，我用小镊子夹起来给奶奶看，奶奶说：还真是隐形的呢。奶奶走出屋后我发现，没夹起来！！！ 2020-03-20 英语四六级考试，我跟宿管阿姨打招呼，宿管阿姨很开心祝我考 100 分。 2020-03-19 2020-03-18 昨晚合租室友说他上火了，我就把我屉子里的黄 连上 清 片给了他。中午跟同事妹子一起在食堂吃饭，正聊的高兴，室友打电话来，我在帮妹子剥鸡蛋壳，就接通打开了扬声器，问他干啥呢，室友大着嗓门说：“哈哈，昨晚谢谢你啊，效果真不错，我屁眼今天不疼了。”玛德感谢你个铲子，劳资成焦点了。 2020-03-17 “心狠手辣的小明舔了自己的手竟然被辣哭了。” 2020-03-16 话说有一个傻媳妇要进城，公公不放心呀，于是叮嘱说：媳妇呀，上城买东西要记得砍价，那东西要价都高。你要记得往一半砍，知道吗？于是媳妇在一家服装店左挑右选，终于选好了一件衣服就问老板：多少钱呀？80。不，40。60 卖你了！30！40 还不行？？？20！得啦，我白送你一套算了。嘿嘿！想蒙我没那么容易，我要半套。 2020-03-15 再一个河塘边，一个旅游者问一个村民：这个河里能洗澡么？村民说：不能，因为这里有鄂鱼。旅游者很吃惊的问：那河的下游呢？村民看了看旅游者说：当然可以了，因为这的鄂鱼怕那的鲨鱼。 2020-03-14 一位挨家挨户推销吸尘器的推销员来到一座新楼房的第一家。他敲门，一位很有耐性的女士来开门。 还没等她有机会开口说话，他就跑进屋内，把自己带的一桶牛粪倒在地毯上。 他说：“夫人，如果这台吸尘器不能出现奇迹把这些牛粪吸干净的话，我把它们吃得干干净净。” 她转身面对着他，得意洋洋地说：“你要在它们上面加一些番茄酱吗？” 推销员不解地问：“你为什么问这个呢？” 她说：“我们刚刚搬进来，电还不通呢。” 2020-03-13 吃饭时，一人说去方便一下老外不解，旁人告诉他方便就是上厕所。 敬酒时，另一人对老外说，希望下次出国时能给予方便，老外纳闷不敢问。 酒席上，电视台美女主持人提出，在她方便的时候会安排老外做专访。 老外愕然：怎么能在你方便的时候？美女主持人说，那在你方便时，我请你吃饭。 老外晕倒！ 2020-03-12 我有个外国朋友是中国通，今天换了个 QQ 签名：“you don‘t know love far high.” 我猜可能他失恋了，觉得对方对爱的含义理解不够深。 问他到底什么意思，丫说：“法海你不懂爱。” 2020-03-11 2020-03-10 前两天防盗门锁坏了，进不了屋，厂家来人半天也没修好，无奈只能 110 报警，割了防盗门！ 没一会儿警察来了，还从所里带了个刚抓的小偷。警察跟小偷说：“快点儿啊，给你十分钟，我这回去还等着下班了。” 小偷：“用不了，五分钟的事儿。”然后，咔咔几下，门开了…开了……连一分钟都没用！ 据说当时厂家专业人士的脸色很难看… 2020-03-09 晚上俩人散步，走到一条比较黒的小路， 女的故意跟那男的撒娇说：“会不会有坏人啊，我怕！” 男的马上挺起胸膛说：“别怕，有哥在。” 女的说：“哥，你都有些什么本事？” 只听那货说：“哥跑的快。” 2020-03-08 上学时有天晚上和一学妹去看电影，看完十一点了。她回不了宿舍，我阴笑着对她说：哈哈，回不了宿舍了把，她低下头羞涩的说：嗯。 然后我笑的更开心了：我能回去，哈哈…… 2020-03-07 有一天，媳妇深情地望着我说：老公，你是什么时候下决心向我求婚的？我想了想回答：额，我每次来你家那条汪都要咬我，有次我来了它居然不咬了？我想你们一定把我当成一家人了。媳妇失望地摇摇头：唉，那是你来的太频繁了，狗狗都不想搭理了。 2020-03-06 公交上，有一女生，和一个外国人英语交谈，交谈声巨大，妹子表情夸张，时不时还浪笑，就这样持续了，很长时间。妹子忽然用中文问司机：某 XXX 站到了吗？司机答：已经过了。妹子发飙了：你怎么不报站啊？司机淡定的答到：讲中文，我怕你听不懂。 2020-03-05 考试前，小红对小明说，如果这次你能考全班第一，我就做你的女朋友。全班同学都听到了，试卷发下来后，大家都默默地把笔放下了，打算交白卷，小明眼泛泪花。 他看了一眼虎背熊腰的小红，默默地把试卷撕下来吃了。 小红微微一笑，在自己的卷子上写下了小明的名字…… 2020-03-04 “孩子，你一定得把字练好！妈妈当年就是没听你外婆的话，导致。。。”这时楼下有人呼唤孩子妈妈，“秃英！快点！三缺一！都等你呐！”孩子终于明白了妈妈所说话的含义，因为他妈妈叫秀英。。。 2020-03-03 小时候，我跟院子里几个小孩，玩躲猫猫游戏，我见我家灶台上有一口大锅，煮猪食的那种锅，我就爬锅里去躲着，然后把锅盖盖上，后来不知道是什么时候我睡着了，他们都没有找到我，晚上的时候，我妈回来就烧火煮猪食，差点没把我烧死….. 2020-03-02 早上晨练，在楼下看到隔壁那家的妻子脸上有伤。两个邻居在那儿议论：“哎呀！她家到底是怎么回事儿？”答：“昨晚你没听到吗，好像是他两口子打架呢。”问：“听到了，咦？她老公不是出差了吗？”答：“半夜回来了呗。” 2020-03-01 以前我爸爸非常惹女人喜欢，总是有女人隔三差五的给他打电话！总惹得我家里天天吵架，我也天天在哭！从我毕业以后，我们家里总算清静了，我的爸爸妈妈也不吵架了！我的班主任也没有给我爸打过电话！ 2020-02-29 医生说：“你为什么要换病房?你的邻床是个极好的病友，他是有名的相声演员。” 病人打断他说：“你说得没错！可我一笑，手术的伤口就嘣开了。” 2020-02-28 一个女生天天给男生送便当，送了 2 个月之后。 男生害羞的对女生说: 便当很好吃我…. 话没说完，女生激动的说: 真的吗? 那是我哥做的，他喜欢你很久了。 2020-02-27 幽灵：上帝，我下次投胎想和天使一样全身洁白，并且带着一对翅膀，但我仍然想吸血。­ 上帝：那你投胎做护舒宝吧。­ 2020-02-26 2020-02-25 二货朋友来我家玩，我给他到了一杯雪碧。他接过放茶几上不小心碰倒了，雪碧洒了出来，二货一看脸都绿了。一把掀翻我家桌子，抓住我的衣领说：“TMD 水里有毒？” 2020-02-24 淘宝上一件商品的一条评价：“我穿着这件新买的斗篷去面包店，因为冷，把胳膊缩在里面。面包店老板以为我是失去 双 臂 的残 疾 人，坚决不收钱，而且很贴心地把面包袋挂在我的脖子上…为了不让店主失望，我用头顶开了门，走了出来…” 2020-02-23 某女生的男友是一个超级斯文的人， 她给男友说，平时斯文没关系，但是啪啪啪的时候能不能粗暴一点！可以骂她！这样比较有情趣！ 她男友经常一边啪啪啪，一边痛诉“你是不是傻，你是不是傻”(≧▽≦)/ 2020-02-22 一天，女神去找禅师：“大师，我其实只想当个普通人，可是他们非把我当女神，好无奈啊。”禅师没说话，递给她一个袋子，让她去后院装垃圾。不一会儿装满了，禅师又递给她一个袋子。女神若有所思地点点头：“大师，您的意思是让我敞开心扉，容纳下一切，才能幸福是吗？”禅师摇摇头：“不，我的意思是…装，你接着装…” 2020-02-21 2020-02-20 有个人超级不会说话，一天朋友家老人过寿，他也应邀出席。最后吃完长寿面，他兴致勃勃地介绍说：“这种面在我们那叫挂面。” 2020-02-19 医生刚给个小学生扎手指查血。针刚扎，小学生放了个巨响的屁，他那彪悍老妈说道：“呀，还给你扎漏气儿了啊？” 2020-02-18 去见女友父母，吃饭的时候她妈问：“现在消费那么高，小伙子每个月能挣多少钱呀？”我叹了口气：“唉，没多少，跟要饭的差不多。”她妈一听，高兴地说：“那每个月岂不是能挣好几万？不错不错！”我。。。 2020-02-17 朋友说：“长得好看的人经常会莫名其妙的被加上各种属性，比如聪明，美丽，大方，善良等等”，而长的难看的就一个词，那就是踏实！说的好有道理，我竟无言以对 2020-02-16 2020-02-15 2020-02-14 今天上完厕所不小心掉了十块钱在里面，想了半天没决定捡不捡。想走又舍不得，想捡起来又下不去手。于是我果断又丢了一百块在里面，总算下得去手了！ 2020-02-13 今天老爸要我去相亲，我说不用了，你马上就要当爷爷了…老爸很惊讶，赶紧把相亲的约定给推了…挂完电话问我：“你什么时候有的对象？”我说没有呀，你不是种了几棵葫芦吗？我看快成熟了……说完我就感觉我的脸火辣辣的疼…… 2020-02-12 2020-02-11 和老婆吵架了…事后很后悔不该不让着她…想送她一个项链哄哄她…可是又不知道买多长的…于是…晚上趁老婆熟睡的时候…偷偷拿绳子在她脖子上量…结果…她醒了 2020-02-10 作业做了很久，顺手打开收音机，一个温柔的声音传出：“如果肤色粉红，脸上的绒毛细嫩柔软，那么说明很健康……”听到这里，忍不住摸了自己的脸，对镜顾盼，再笑一笑，样子健康可爱。这时，又听播音员说道：“好，听众朋友，这次我们的《养猪知识讲座》就到这里。” 2020-02-09 老师正在讲课，看到两个学生枕着书睡觉，其中一个是成绩优秀的学生，一个是差生。教师把那个差生拉起来骂道：“你这个不思上进的家伙，一看书就睡觉，你看人家连睡觉也在看书。” 2020-02-08 晚上回家，听到巷子有哭声，靠近一看，原来是一衣衫不整的女子在哭。问怎么了，小姐答：“我被色狼侵犯了！”我：“没事吧？”小姐答：“他突然从背后抓住我的胸部，然后就把我放了……”我：“那还哭什么呢？”小姐答：“因为……那色狼居然说，真倒霉，竟然抱到个男的。” 2020-02-07 一天和同事出去吃早餐，同事点了担担面，加鸡蛋，面盛上来之后同事没看到面便问：”我的蛋呢？“服务员很自然的答道：“在下面。” 2020-02-06 2020-02-05 2020-02-04 在自习室，由于最近要考试了，人满为患。一哥们儿好不容易发现个空位刚坐下，旁边是一妹子，那哥们儿就滔滔不绝的和妹子讲话：”妹子，你哪个院的啊？多大啦？”过了一会，妹子终于不耐烦了，扔下一句：”你有病啊？” 就走了。正当我暗地嘲笑那哥们儿热脸贴上冷屁股时，他淡定的掏出手机，拨打了一个电话号码：”喂？媳妇儿，座位已经占好了，嗯嗯，挨着的，快来吧”。 2020-02-03 2020-02-02 2020-02-01 2020-01-31 2020-01-30 2020-01-29 2020-01-28 2020-01-27 王老汉想买彩票又不想出门，于是把两元钱冲进了马桶。 2020-01-26 2020-01-25 2020-01-24 下午我爹骂我..后来情绪激动还扇了我一耳光，当时想缓解一下气氛，本来想说“爸，你饿吗，我给你弄点吃的吧？”结果一时嘴快说成了：“爸，你没吃饭是吧？” 2020-01-23 2020-01-22 2020-01-21 2020-01-20 “小明，你来给大家念一下’软‘字的拼音念法。” “日完——软！” “不对！我怎么教的？小红，你来。” “好的老师，日五晚——软！” “你们这帮学生真是要气死我，小华你来！” “嗯，应该是，日吾俺——软。” “没有一个记性好的，一天天在想什么。老师最后再教一遍，跟我念：日五晚俺——软！” “日五晚俺——软！” 2020-01-19 儿子每天都笑得很开心。我问儿子：“为什么你天天都那么开心？”老公在旁边说：“因为他没老婆。” 2020-01-18 某人在精神病院实习，忽然一神经病患者手持一把菜刀向他追来，这人转头就跑，直到跑到一条死胡同，心想这下完了，那个病人说：给你刀，该你追我了。 2020-01-17 2020-01-16 刚刚无聊，我试着给 10086 发信息：“我想你了。” 没想到 10086 真的给回信息了：“来找我啊，死鬼！” 我吓得赶紧放下了爸爸的手机。 2020-01-15 2020-01-14 今天上班无聊中在玩手机，突然看到老板过来了，我就匆忙把手机收起来，一不小心把手机掉地上了，我还慌乱中，老板弯腰帮我把手机捡了起来，然后跟我说了句我这辈子都能记住的话。他说:没事，你玩你的，只要你把事情做好了，我不会说你，没必要做样子给我看，我也不喜欢别人只做样子；今天我是你老板，说不定哪天我破产，你发达了，我就要给你打工呢？做人实实在在就好……结果第二天我因为穿运动鞋被开除了！ 2020-01-13 我问爸爸:”为什么我只有大伯，二伯，四叔，五叔?为什么没有三叔?我三叔呢?死了吗？” 爸爸抬手一耳刮子给我抽懵了。 2020-01-12 最近来亲戚了，不舒服就和男朋友闹别扭，持续了一周了，最近两天死皮赖脸的缠着我！我懒得搭理他，就指了指坏掉的空调说道：男人都是大猪蹄子，就和破空调一样，我热了偏要吹热风，我冷了偏要吹凉风！男朋友也怒了，说到：你连空调都不如，最起码它知道吹。 2020-01-11 在某个风和日丽的下午，班主任没在，我们逃课上网，刚翻过墙，边上是一银行。一辆运钞车，两名特警拿枪指着我们问：‘‘干什么的？’’我们没见过这阵式，当时就吓傻了，弱弱的说：‘‘逃课。’’特警蜀黍说：‘‘滚回去。’’我们刚翻回去，看见校长站在墙边，对我们喊到：‘‘你们几个，干什么的？’’我同学反应特快，说：‘‘找人。’’校长大吼：‘‘给我滚出去。’’…… 2020-01-10 麋鹿在森林里迷路了 于是，给它的好朋友长颈鹿打电话：喂？我迷路啦！ 长颈鹿：嗯，我长颈鹿啦… 2020-01-09 2020-01-08 2020-01-07 老婆做了一个新发型，我看了忧伤的说：说好了一起到白头，你却半路焗了油。正在厨房忙碌的妈妈听到出来说：儿子，知足吧，我也曾对你爸说过，说好一起到白头的，他却半路秃了瓢…… 2020-01-06 2020-01-05 2020-01-04 一个农夫的女儿实在太丑了，他只好让她去玉米地当稻草人吓唬乌鸦。结果，她不仅吓走了乌鸦，甚至有三只乌鸦吓得把一些玉米送了回来。 2020-01-03 有个老头子去看病，医生给他开了一副药然后对他说：”药效十二小时”。老头子点了头就笑着走了，老头子边走边笑，回到家还在不停的笑啊笑。家人奇怪就问：“你怎么回事啊”老头说：“尼玛，这医生开的什么药啊，要笑十二个小时，笑得快累死了” 2020-01-02女：有三套房吗？ 男：没有！ 女：有奔驰、宝马吗？ 男：没有！ 女：有 7 位数存款吗？ 男：没有！ 女：那你有啥？ 男：我……… 女转身就走。突然男的说：我管理几百人。其中有很多律师、教授、企业家，还有很多帅哥美女。 女立刻回头抱住男的腰，满脸崇拜地说道：死鬼，你不早说，这就够了！！那你是什么公司老总？ 男：我是群主 2020-01-01 某人在精神病院实习，忽然一神经病患者手持一把菜刀向他追来，这人转头就跑，直到跑到一条死胡同，心想这下完了，那个病人说：给你刀，该你追我了。 2019-12-31 跟我妈一块坐地铁，我在玩手机，旁边一个熊孩子一巴掌把我手机打掉了，然后他立即缩回他妈妈怀里，他妈妈说：他还是孩子，不懂事。说完了也不帮我把手机捡起来道个歉啥的。我二话不说捡起手机，然后对着小男孩后脑勺一巴掌扇过去，小男孩当时就哭了，他妈妈立马就急了，我直接缩回我妈怀里，我妈来了句：他还是孩子，不懂事。 2019-12-30 2019-12-29 2019-12-28 一名劫匪慌忙中窜上了一辆车的后座，上车后发现主驾和副驾的一男一女疑惑地回头看着他，他立即拔出枪威胁到“赶快开车，甩掉后面的警车，否则老子一枪崩了你！”于是副驾上的男人转过脸对那女的说“大姐，别慌，听我口令把刚才的动作再练习一遍，挂一档，轻松离合，轻踩油门，走…走，哎 走…哎，哎，对，走走… 2019-12-27 2019-12-26 悟空和唐僧一起上某卫视非诚勿扰,悟空上台,24 盏灯全灭。理由:1.没房没车只有一根破棍. 2.保镖职业危险.3.动不动打妖精,对女生不温柔. 4.坐过牢,曾被压五指山下 500 年。唐僧上台，哗!灯全亮。 理由:1.公务员； 2.皇上兄弟，后台最硬 3.精通梵文等外语 4.长得帅 5.最关键一点：有宝马！ 2019-12-25 2019-12-24 一个猎人开枪打了一只狐狸，然后猎人死了。狐狸说哈哈哈，我是反射狐。 2019-12-23 2019-12-22 小时候我妈打我，我就哭，我妈就说：不准哭，再哭还打你，然后我就不敢再哭了。然后下次打我我就不哭她说：哎哟，皮长厚了，叫你不哭，叫你不哭。然后我被打的更惨了。妈，你开心就好。 2019-12-21 2019-12-20 2019-12-19 2019-12-18 医院挂号处遇到一个让我心动的女孩，她排外队伍的最前头，我在她隔几人的身后。好几次鼓了鼓勇气想要走近搭讪，却都无功而返。眼瞅着她从小窗里拿出病例本转身向我这边走来，我知道这擦身而过或抱憾终生，这才红着脸怯生生地挤出几个字：“你有病吧？” 2019-12-17 窗外，雨淅沥沥的下。她双眼望着我，“见家长吧。”我不禁心头一震，这么久了，她是第一次对我说这样的话，我眼泛泪花，有点哽咽，试探问道：“是不是有点早？”她情绪竟然有些激动：“还敢讨价还价！你已经两天没交作业了！叫家长！” 2019-12-16 我一朋友去年算命说他今年命犯桃花，会被一个忽然出现的女人伤得很深，昨天他在拐角处被一大妈骑电动车撞了，现在还在医院里躺着。 2019-12-15 一个体弱男经常在学校被人欺负，早上，被同班同学欺负，放学被别班欺负 于是有一天他偷偷带了一根绳子，跑到一个荒郊野外，把绳子挂在树上，然后……….. 坐在上面当起了秋千，心情好多了 2019-12-14 前些日子遇到位江湖大哥，大哥小腿两边各纹一条鲤鱼，颜色一红一黑，左边鱼头朝上，右边朝下，形态遒劲，面目狰狞，很是骇人。吃饭时终于有人问到了纹身的寓意，大哥点上一只烟，说：”我出生在 1976 年 3 月 15 日…”我们都竖起耳朵，等待着接下来注定血雨腥风的故事。大哥押口烟，接着说：”我是双鱼座” 2019-12-13 2019-12-12 同学一见面就跟我诉苦，说他前段时间总盗汗，一睡着就出汗，医院检查花了好几百，后来又找了个老中医开了十来副中药，喝了也不管用，而且一天比一天厉害。我问：“后来呢?咋治好的?”一问到这，我明显看到同学的嘴角一抽搐，愤愤道：“我换了个薄被子。” 2019-12-11 2019-12-10 吃坏东西，几天持续拉肚子，和老公出去没多久又有感觉了，马上往回赶。途中一摩托车快速朝我们方向过来，惊吓着躲闪还是被带到了，受伤倒是木有，就是过程中放松了。结果是我听到摩托车大哥打电话说：“我把一个人撞出屎来了……” 笑尿了。。。撞出屎来了。。。。。 2019-12-09 某人去厕所怎么也打不开马桶盖，着急就把屎拉在了马桶盖上，方便以后突然发现墙壁上有个按钮，就按了一下，没想到盖子突然弹开，把屎弹在天花板上。他很难为情，叫来服务员指着天花板：我给你 200 块钱你帮我把这个清理干净。服务员看了看天花板对他说：我给你 800 块钱你告诉我你是怎么把屎拉在天花板上的 2019-12-08 2019-12-07 下午肚子饿，看见同事桌上有瓶酸奶，想都没想就喝了，一会同事来了大叫到：“我的洗面奶怎么不见了！108 块啊！”哥没说话，只是默默的走向厕所，一顿抠嗓子，老难受了，把东西拼命的吐，直到吐出酸水，好不容易吐的差不多了，眼泪叭嚓滴回到座位上时，同事抱着一个瓶子 说：“吓死我了，洗面奶滚到桌子下了，我的酸奶怎么又不见了呢。”哥心里直骂：你奶奶个熊滴，喝你点酸奶，把人往死里整。 2019-12-06 一个乞丐问大师：“大师，为什么我这么可怜，难道就这样乞讨一生吗？” 大师拿出一枚硬币，抛向空中，落在乞丐面前。“大师，您是说人生就像硬币一样，都会有正反面吗？” 大师：“拿着这块钱，再不滚我抽你。” 2019-12-05 2019-12-04 去加油，加油站的大姐说:“四百三十五” 老婆问:“抹个零，四百三行不行?” 我对她说:“别丢人，你以为买菜啊，还讲价。” 她说“不问问怎么知道行不行?” 我说“不用问，加油站能讲价我裸奔回家”。 大姐笑着看看我说“行，就收四百三。” 2019-12-03 吃火锅，看见火锅店的墙上提醒，羊是自己养的，菜是自己种的油是自己榨的，提醒顾客放心使用。买单的时候我，悄悄告诉老板，钱是我自己印的，请放心使用，老板追了我好几条街没追上，真有意思，腿是我自己长的，想往哪里跑就往哪里跑。 2019-12-02 2019-12-01 记得那年高考成绩出来时，一哥们的分数是 369，本科线 399，他当时那叫一个悲痛万分，悔不当初，恨不能用他 300 斤肥肉换 30 分!!!结果有人提醒他，399 是文科的本科线，你激动个啥!他一听，犹如柳暗花明又一村，查了一下理科本科线，妈的，370! 2019-11-30 一位年轻妈妈抱着女儿进了医院。女儿天真地问： “妈妈，我们来干嘛？” 妈妈说：“打针啊。” 女儿问：“干嘛要打针，针做错什么事了么？打针针不疼么？” 5 分钟后，女儿开始咆哮 “这是针打我！这是针打我！” 2019-11-29 初三的时候班主任直接把办公地点换到班级里最后一排靠门的角落 那是一节化学课 由于上节化学课学了钠元素老师为了复习就问道“钠是什么” 大家默不作答 老师又很大声的说“钠！是！什！么！”就在这时班主任的手机在后排响了起来“钠是一条神奇的天路” 沉默了两秒后全班爆笑 当时化学老师的脸都绿了 2019-11-28 高中时候，班里一哥们，1991 年生，不大，就是特老相….. 以下是他坐公交时发生的一点事情： 高二时候，这哥们座公交去学校，因为路途长，百无聊赖的时候，邻座的一个 35 岁左右的男人跟他搭话，那人张嘴就来句：“大哥去哪里？ 这哥们也许是平常遭遇这样的待遇多了，也并不万分惊奇，颇平静的回答：“三中”。那男人第二句话：“噢，去看孩子吧？孩子上学挺苦的……” 那哥们脸部抽搐了一下，没吭声。 第三句话：“大哥，你孩子上几年纪了？”那哥们是真烦了，也不解释，顺口来了句：“高一” 这个时候，经典出现了。那男人异常惊奇地瞪大眼睛看着那哥们，看了足足十秒钟，来了句:“大哥，那您结婚可是挺晚的啊！” 2019-11-27 2019-11-26 晚上去奶奶家吃火锅，饭桌上我加夹了一块排骨，不小心掉在地上了！ 怪心疼的，就问我奶奶：“奶奶，你今天拖地了吗？” 奶奶说：“拖了，我每天早晨都拖地。” 然后我就放心的把排骨放到嘴里。 紧接着我奶奶又说：“你爷爷晚上泡脚的水我不倒，留着早晨拖地。。。” 2019-11-25 有人问：“胡歌你演技这么好你怎么不上天呢？” 结果 胡歌提名飞天奖最佳男演员。 2019-11-24 名称 问：什么名字，日本人听起来是日本名字，中国人一听就知道是中国人起的？ 答：房屋中介。 2019-11-23 小鸡：“为什么人类都有名字，而我们都叫做鸡？” 母鸡：“人活着的时候都有名字，死了就叫鬼罢了；我们鸡活着时没有名字，死了就有很多名了啦！” 小鸡：“什么名？” 母鸡：“炸鸡、咖喱鸡、白斩鸡、烧鸡、叫花鸡。。。” 2019-11-22 我朋友有一次坐黑车，被交警拦下。 司机解释说：“我们俩是朋友，我知道他号码。”说着，便拨打我朋友手机。 因为我朋友坐他车好几次，所以互相留了号码，手机立刻响了。 他拿出手机，交警瞧了瞧，只见屏幕上显示”黑车司机”。 2019-11-21 2019-11-20 小明和爸爸俩人坐公交车。 小明：爸爸，什么时候到啊? 爸爸：停了就到了。 小明：什么时候停啊? 爸爸：到了就停了。 。。。 2019-11-19 “谁能想到，这名年仅 16 岁的少女，在四年前只是一个年仅 12 岁的少女。” 2019-11-18 正在外面遛狗，忽然一个人把我的狗杀了。 我问：“为什么要杀我的狗？” 他回答：“有人花钱说要你狗命!” 。。。 没见到这么二的人，就跟他聊了一会。 他突然问到：“你有女朋友吗？” 我说：“还没呢！” 突然他就用刀子捅了过来，还说到：“对不起，单身狗也是狗！” 我说：“可是。。我有。。。男朋友。。。。啊” 他再捅一刀：“秀恩爱死的快” 。。。 2019-11-17 有个小朋友我叫他跳个舞，他弱弱的说了句“我不会”。 我就说“男孩子要自信一点，大胆一点”。 结果他嚣张的喊了一句“老子不会”。 2019-11-16 2019-11-15 2019-11-14 读初中时候，学校谈朋友都的很多。 一天，我爹给了我一张漂亮女人照片说：这是女孩子她妈妈照片，漂亮吧，那女儿一定更漂亮，今天爹告诉你个秘密，咱们家在你很小的时候给你定了娃娃亲，就是这女人的女儿，现在搬到外地了，你可别谈朋友，对不起人家啊，收好照片，等你考上大学就安排你们见面。 终于上大学了，今天在宿舍讲了我的故事，他们都表示不信。 于是我拿出了照片，结果我一宿舍童鞋看了一眼说：这特么这不是武藤兰么。 2019-11-13 2019-11-12 2019-11-11 2019-11-10 2019-11-09 2019-11-08 2019-11-07 前天在公交上，和别人撞衫了，别问我谁穿更帅，丫的竟然是个小男孩！就这样众目睽睽之下，一大一小素未蒙面的俩个人穿着一样的衣服傻站在那，我已经很尴尬了。 那小孩看了我半天，好奇的问我：叔叔，你的衣服也是在奇奇宝贝屋买得吗？ 2019-11-06 下了出租车发现手机掉车上了，在雨中追了好长一截大喊：师傅等等，师傅等等！师傅停车了。这时发现手机拿在手上，于是对师傅说：下雨天路滑，您慢点开啊。师傅：…… 2019-11-05 2019-11-04 入住酒店，房间烟味太重，打给前台，前台说：“您稍等我们来给您做无烟处理” 我心想现在科技好发达。 二分钟后来了个大叔，打开我房间所有窗户，然后走了。 2019-11-03 老婆心血来潮要那个，老公笑了笑，掏出一百元丢给老婆，然后睡一边去了。 老婆：“给了钱就不做了?” 老公：“嗯!” 老婆：“那你说说这叫什么费用?” 老公：“保护费啊!” 老婆：“保护什么?” 老公：“肾!” 2019-11-02 地铁上，一个男的觉得对面女孩很面熟，就一直盯着他看。 女孩被看烦了，就问：“你瞅啥?” 那男孩就说：“我觉着你很面熟，像我以前那个女朋友。” 那个女孩怒道：“我 TM 就是你以前那个女朋友。” 男孩懵比了。。。 2019-11-01 2019-10-31 2019-10-30 足球教练在赛前对他的队员们面授机宜：“你们抢不到球，就往对方腿上踢！” 一队员忽然道：“比赛用的球去那儿了？” 另一队员：“不用找了，没球一样踢。” 2019-10-29 2019-10-28 2019-10-27 快躲起来 2019-10-26 2019-10-25 我是一个苦 b 的程序员，今晚加班到快通宵了，困得快睁不开眼了，女上司很关心，问我要不要吃宵夜。我没好气地说，宵夜就算了，能让我睡一觉就行了。女上司红着脸说了句讨厌啊，然后坐在我身边不动，好像距离我很近，搞得我很紧张，难道她发现我的程序出了 bug？ 2019-10-24 今天是 1024 程序猿节，首先祝广大猿们节日快乐，BUG 越写越多。下面来一个关于程序员的段子： “你们用盗版的时候有想过做出这款软件的程序员吗？他们该如何养家糊口？” “哈哈哈，别逗了，程序员哪有家要养啊！ 2019-10-23 小白兔钓鱼记 第一天，小白兔去河边钓鱼，什么也没钓到，回家了。 第二天，小白兔又去河边钓鱼，还是什么也没钓到，回家了。 第三天，小白兔刚到河边，一条大鱼从河里跳出来，冲着小白兔大叫： 你要是再敢用胡箩卜当鱼饵，我就扁死你！ 2019-10-22 2019-10-21 今天带 2 岁儿子第一次吃臭豆腐。 儿子咬了一口：“妈妈，这是谁拉的，这么好吃！”老公听了后说：“这几天好好看着他，别自己拉屎吃了！ 2019-10-20 一天，美国、英国和大陆的特种部队在一起训练，为了比出谁是最优秀的，他们举办了一个比赛——把一只兔子放进森林里，三个部队谁在一天之内找到它就是最强的。只见美国特种兵立刻开会制定方案，迅速展开了地毯式搜索，结果一无所获；英国特种兵在森林外面一字排开，拿着个喇叭对里面喊：里面的兔子听好了，你已经被我们包围了，快点自己投降吧！结果当然什么都没出现；而大陆的特种兵似乎特别有把握，一整天在那里聊天赌博，一直到黄昏的时候，士兵们才拿起家伙懒洋洋地走进了森林，在一阵动物的惨叫声后，他们牵着一头鼻青脸肿的熊走了出来，只见那只熊不停地说：“别打了，我是兔子。” 2019-10-19 2019-10-18 2019-10-17 小时候邻居大爷骗我说:“其实轻功很简单，就是左脚用力的踩一下右脚，然后往上一跳就行了。” 现在看来这是多么明显的谎言啊，可我当时还真就信了。 回家以后接着试了一下，结果给我疼哭了。 我妈听到哭声立刻冲进了屋里:“怎么了？” 然后 我爸一脸懵逼的说道:“不知道啊，他进来以后只说了一句爸爸你看，然后就把自己踩哭了。” 2019-10-16 2019-10-15 一位老司机语重心长的对一个刚上路的小伙子说道：“你知道这路上什么车最惹不起么？”。“法拉利？保时捷？。。。”小伙子脱口而出。老司机摇了摇头说：“是五菱宏光。”小伙不解，老司机看了看自己的瘸腿，淡淡的说了句：“因为你永远不知道他车上会下来多少人。。。。” 2019-10-14 2019-10-13 有次在学校的浴室澡堂子洗澡，水特别烫，洗完回寝，我随口说了一句：“真是的，今天浴室的水烫死人了。。。” 室友噌的一下从床上探出身子，惊恐里还有点小激动，：“啊？！真的吗？谁呀谁呀？？” 2019-10-12 2019-10-11 2019-10-10 一天，孟婆在煮孟婆汤，想尝尝咸淡，喝了一口，满意地笑了。想尝尝咸淡，喝了一口，满意地笑了。想尝尝咸淡，喝了一口，满意地笑了。想尝尝咸淡，喝了一口，满意地笑了。想尝尝咸淡，喝了一口，满意地笑了。想尝尝咸淡，喝了一口，满意地笑了… 2019-10-09 2019-10-08 我们隔壁有一个 80 多岁的大爷，昨天在小区树下发现一条黑色的蛇，都冻僵了！ 他就把蛇揣到怀里面，想给它一点温暖。 今天一大早他就在树上挂了个牌子: “不准随地大小便” 2019-10-07 2019-10-06 昨日，某高校自主招生复试举行，笔试和面试两轮测试。1 名考生对阵 4 名专家，一些考题让考生感到措手不及。考官：“请你出一道题把我难住，前提是你知道答案。” 该考生被问懵，反问考官：“你知道我爷爷叫什么名字吗？” 2019-10-05 当你觉得自己很牛逼的时候， 当你以为自己很了不起的时候， 就要冷静下来想一想 …… 怎么让全世界都知道这个事 2019-10-04 跟女朋友一起去三亚旅游，在海滩一颗树下乘凉，仰头看到树上有几只鸟，然后，突然几滴白色的鸟屎掉我脸上。 然后女朋友说，你看你，防晒都没抹均匀，后面你们懂得！ 2019-10-03 一个真实的段子。我：xx，你外甥奶粉吃 pre 段还是 1 段的？徒弟：不间断！我：。。。 2019-10-02 老师说:“今天的语文作业是《致老师》”。小明举手道:“老师,您还是去医院吧,我们治不了。” 2019-10-01 登山者与老和尚喝茶。我说:我放不下些事,放不下一些人。他说:没有什么东西是放不下的。我说:可我偏偏放不下。他说:你不是喜欢喝茶吗，说完就递我一个茶杯然后往里面倒热水,一直倒到热水溢出来。真尼玛疼啊！我就把一整壶开水浇在老和尚脑袋上了,警察同志,全部过程就是这样,是他先烫的我。。。 2019-09-30 领导提拔一美女后，几次要潜规则该美女，都被她以各种理由拒绝了。 对此领导非常生气，过几天就把该美女职位降了。 其他人对此颇不理解，问领导原因。 领导说：“该女在领导面前放不开，难以胜任。” 2019-09-29 程序员见到科比，非常崇拜，于是就有下面一段对话 程序员：“你为什么这么成功，能告诉我成功的秘诀是什么吗？” 科比：“你见过城市凌晨四点的样子吗？” 程序员：“嗯，这个时候我一般在写代码！” 科比：“。。。。。” 2019-09-28 第一个用蚂蚁花被（呗）的男人 2019-09-27 一个女人总在白天丈夫出门工作时搞外遇。 一天，她 9 岁的儿子刚好回家，目睹了这一切，他躲进了卧室的衣柜里。 突然，丈夫也回家了。 她赶紧让情人躲进衣柜里，却不知道这里已经躲了一个男孩。 男孩：“这里好黑啊。” 男人：“是啊。” “我有个棒球。” “不错。” “你想买吗？” “不了吧。” “我爸在外面呢。” “行吧，多少钱？” “300 块。” 。。。 过了几个星期，男孩和男人再次在衣柜里见面了。 男孩：“这里好黑啊。” 男人：“是啊。” “我有个棒球手套。” 回忆起上次的谈话，男人无奈的问道：“多少钱啊？” “700 块。” 。。。 又过了几天，男孩的父亲对他说：“把棒球手套拿上，咱们出去玩一会儿。” 男孩说：“不行啊，我把棒球和手套都卖掉了。” 父亲问：“你卖了多少钱？” “1000 块。” 父亲：“你怎么能这么坑自己的朋友？快和我去教堂忏悔！” 他们一起到了教堂，男孩走进告解室。 男孩：“这里好黑啊。” 神父：“你他妈有完没完？！再说一句试试！”","categories":[{"name":"代码之外","slug":"代码之外","permalink":"https://iamtaoxin.com/categories/%E4%BB%A3%E7%A0%81%E4%B9%8B%E5%A4%96/"}],"tags":[{"name":"每日一笑","slug":"每日一笑","permalink":"https://iamtaoxin.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E7%AC%91/"}]},{"title":"关于 Node.js 中的 Cron 定时任务","date":"2020-03-02T08:56:54.000Z","path":"2020/03/02/node-cron/","text":"cron 是一个 linux 下的定时执行工具，可以在无需人工干预的情况下运行作业。 安装$ npm install -g cron Useconst cronJob = require(\"cron\").CronJob; //每秒钟执行一次 new cronJob( \"* * * * * *\", function () &#123; //your job code here &#125;, null, true, \"Asia/Chongqing\" ); //每隔30秒执行一次，会在0秒和30秒处执行 new cronJob( \"*/30 * * * * *\", function () &#123; //your job code here &#125;, null, true, \"Asia/Chongqing\" ); //从早上8点到下午18点，每隔半个小时执行一次，会在0分和30分处执行 new cronJob( \"* */30 8-18 * * *\", function () &#123; //your job code here &#125;, null, true, \"Asia/Chongqing\" ); //在每天的10点和18点的第26分钟各执行一次 new cronJob( \"* 26 10,18 * * *\", function () &#123; //your job code here &#125;, null, true, \"Asia/Chongqing\" ); 不立即执行，人工启动 const jobid = new cronJob( \"* 26 10,18 * * *\", function () &#123; //your job code here &#125;, null, false, \"Asia/Chongqing\" ); // Asia/Shanghai jobid.start(); cron 表达式 顺序 秒 分钟 小时 日期 月份 星期 年（可选） 取值 0-59 0-59 0-23 1-30（31） 1-12 1-7 允许特殊字符 ,-*/ ,-*/ ,-*/ ,-*/?LWC ,-*/ ,-*/L#C 1970-2099 , - * / 字段含义*：代表所有可能的值 -：指定范围 ,：列出枚举 例如在分钟里，\"5,15\"表示5分钟和20分钟触发 /：指定增量 例如在分钟里，\"3/15\"表示从3分钟开始，没隔15分钟执行一次 ?：表示没有具体的值，使用?要注意冲突 L：表示last，例如星期中表示7或SAT，月份中表示最后一天31或30，6L表示这个月倒数第6天，FRIL表示这个月的最后一个星期五 W：只能用在月份中，表示最接近指定天的工作日 #：只能用在星期中，表示这个月的第几个周几，例如6#3表示这个月的第3个周五 示例0 * * * * ? 每1分钟触发一次 0 0 * * * ? 每天每1小时触发一次 0 0 10 * * ? 每天10点触发一次 0 * 14 * * ? 在每天下午2点到下午2:59期间的每1分钟触发 0 30 9 1 * ? 每月1号上午9点半 0 15 10 15 * ? 每月15日上午10:15触发 *&#x2F;5 * * * * ? 每隔5秒执行一次 0 *&#x2F;1 * * * ? 每隔1分钟执行一次 0 0 5-15 * * ? 每天5-15点整点触发 0 0&#x2F;3 * * * ? 每三分钟触发一次 0 0 0 1 * ? 每月1号凌晨执行一次 你可以在 http://cron.qqe2.com/ 中验证 cron 表达式","categories":[{"name":"技术整理","slug":"技术整理","permalink":"https://iamtaoxin.com/categories/%E6%8A%80%E6%9C%AF%E6%95%B4%E7%90%86/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://iamtaoxin.com/tags/Node/"}]},{"title":"Vue + Qiankun 快速实现前端微服务","date":"2020-03-01T12:06:10.000Z","path":"2020/03/01/vue-qiankun/","text":"本文介绍 Vue 项目如何实现前端微服务 一、前言什么是微前端 Techniques, strategies and recipes for building a modern web app with multiple teams that can ship features independently. – Micro Frontends 微前端是一种多个团队通过独立发布功能的方式来共同构建现代化 web 应用的技术手段及方法策略。 更多关于微前端的相关介绍，推荐大家可以去看这几篇文章： Micro Frontends Micro Frontends from martinfowler.com 可能是你见过最完善的微前端解决方案 微前端的核心价值 qiankunqiankun 是蚂蚁金服开源的一套完整的微前端解决方案。具体描述可查看 文档 和 Github。 下面将通过一个微服务 Demo 介绍 Vue 项目如何接入 qiankun，代码地址：micro-front-vue 二、配置主应用 使用 vue cli 快速创建主应用； 安装 qiankun $ yarn add qiankun # 或者 npm i qiankun -S 调整主应用 main.js 文件：具体如下： import Vue from \"vue\"; import App from \"./App.vue\"; import router from \"./router\"; import &#123; registerMicroApps, setDefaultMountApp, start &#125; from \"qiankun\"; Vue.config.productionTip = false; let app = null; /** * 渲染函数 * appContent 子应用html内容 * loading 子应用加载效果，可选 */ function render(&#123; appContent, loading &#125; = &#123;&#125;) &#123; if (!app) &#123; app = new Vue(&#123; el: \"#container\", router, data() &#123; return &#123; content: appContent, loading &#125;; &#125;, render(h) &#123; return h(App, &#123; props: &#123; content: this.content, loading: this.loading &#125; &#125;); &#125; &#125;); &#125; else &#123; app.content = appContent; app.loading = loading; &#125; &#125; /** * 路由监听 * @param &#123;*&#125; routerPrefix 前缀 */ function genActiveRule(routerPrefix) &#123; return location => location.pathname.startsWith(routerPrefix); &#125; function initApp() &#123; render(&#123; appContent: \"\", loading: true &#125;); &#125; initApp(); // 传入子应用的数据 let msg = &#123; data: &#123; auth: false &#125;, fns: [ &#123; name: \"_LOGIN\", _LOGIN(data) &#123; console.log(`父应用返回信息$&#123;data&#125;`); &#125; &#125; ] &#125;; // 注册子应用 registerMicroApps( [ &#123; name: \"sub-app-1\", entry: \"//localhost:8091\", render, activeRule: genActiveRule(\"/app1\"), props: msg &#125;, &#123; name: \"sub-app-2\", entry: \"//localhost:8092\", render, activeRule: genActiveRule(\"/app2\") &#125; ], &#123; beforeLoad: [ app => &#123; console.log(\"before load\", app); &#125; ], // 挂载前回调 beforeMount: [ app => &#123; console.log(\"before mount\", app); &#125; ], // 挂载后回调 afterUnmount: [ app => &#123; console.log(\"after unload\", app); &#125; ] // 卸载后回调 &#125; ); // 设置默认子应用,与 genActiveRule中的参数保持一致 setDefaultMountApp(\"/app1\"); // 启动 start(); 修改主应用 index.html 中绑定的 id ，需与 el 绑定 dom 为一致; 调整 App.vue 文件，增加渲染子应用的盒子: &lt;template&gt; &lt;div id&#x3D;&quot;main-root&quot;&gt; &lt;!-- loading --&gt; &lt;div v-if&#x3D;&quot;loading&quot;&gt;loading&lt;&#x2F;div&gt; &lt;!-- 子应用盒子 --&gt; &lt;div id&#x3D;&quot;root-view&quot; class&#x3D;&quot;app-view-box&quot; v-html&#x3D;&quot;content&quot;&gt;&lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; export default &#123; name: &quot;App&quot;, props: &#123; loading: Boolean, content: String &#125; &#125;; &lt;&#x2F;script&gt; 创建 vue.config.js 文件，设置 port : module.exports = &#123; devServer: &#123; port: 8090 &#125; &#125;; 三、配置子应用 在主应用同一级目录下快速创建子应用,子应用无需安装 qiankun 配置子应用 main.js: import Vue from \"vue\"; import VueRouter from \"vue-router\"; import App from \"./App.vue\"; import routes from \"./router\"; import \"./public-path\"; Vue.config.productionTip = false; let router = null; let instance = null; function render() &#123; router = new VueRouter(&#123; base: window.__POWERED_BY_QIANKUN__ ? \"/app1\" : \"/\", mode: \"history\", routes &#125;); instance = new Vue(&#123; router, render: h => h(App) &#125;).$mount(\"#app\"); &#125; if (!window.__POWERED_BY_QIANKUN__) &#123; render(); &#125; export async function bootstrap() &#123; console.log(\"vue app bootstraped\"); &#125; export async function mount(props) &#123; console.log(\"props from main app\", props); render(); &#125; export async function unmount() &#123; instance.$destroy(); instance = null; router = null; &#125; 配置 vue.config.js const path = require(\"path\"); const &#123; name &#125; = require(\"./package\"); function resolve(dir) &#123; return path.join(__dirname, dir); &#125; const port = 8091; // dev port module.exports = &#123; /** * You will need to set publicPath if you plan to deploy your site under a sub path, * for example GitHub Pages. If you plan to deploy your site to https://foo.github.io/bar/, * then publicPath should be set to \"/bar/\". * In most cases please use '/' !!! * Detail: https://cli.vuejs.org/config/#publicpath */ outputDir: \"dist\", assetsDir: \"static\", filenameHashing: true, // tweak internal webpack configuration. // see https://github.com/vuejs/vue-cli/blob/dev/docs/webpack.md devServer: &#123; // host: '0.0.0.0', hot: true, disableHostCheck: true, port, overlay: &#123; warnings: false, errors: true &#125;, headers: &#123; \"Access-Control-Allow-Origin\": \"*\" &#125; &#125;, // 自定义webpack配置 configureWebpack: &#123; resolve: &#123; alias: &#123; \"@\": resolve(\"src\") &#125; &#125;, output: &#123; // 把子应用打包成 umd 库格式 library: `$&#123;name&#125;-[name]`, libraryTarget: \"umd\", jsonpFunction: `webpackJsonp_$&#123;name&#125;` &#125; &#125; &#125;; 其中有个需要注意的点： 子应用必须支持跨域：由于 qiankun 是通过 fetch 去获取子应用的引入的静态资源的，所以必须要求这些静态资源支持跨域； 使用 webpack 静态 publicPath 配置：可以通过两种方式设置，一种是直接在 mian.js 中引入 public-path.js 文件，一种是在开发环境直接修改 vue.config.js: &#123; output: &#123; publicPath: `//localhost:$&#123;port&#125;`; &#125; &#125; public-path.js 内容如下： if (window.__POWERED_BY_QIANKUN__) &#123; // eslint-disable-next-line no-undef __webpack_public_path__ = window.__INJECTED_PUBLIC_PATH_BY_QIANKUN__; &#125; 至此，Vue 项目的前端微服务已经简单完成了。 但是在实际的开发过程中，并非如此简单，同时还存在应用间跳转、应用间通信等问题。","categories":[{"name":"技术整理","slug":"技术整理","permalink":"https://iamtaoxin.com/categories/%E6%8A%80%E6%9C%AF%E6%95%B4%E7%90%86/"}],"tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://iamtaoxin.com/tags/Vue-js/"}]},{"title":"雕刻","date":"2019-12-09T11:14:45.000Z","path":"2019/12/09/sugeladi/","text":"苏格拉底的父亲是以为著名的石雕师傅，在苏格拉底很小的时候，有一次他父亲正在雕刻一直石狮子，小苏格拉底观察了好一阵子，突然问父亲：“怎样才能成为一个好的雕刻师呢？” “看！”父亲说，“以这只石狮子来说吧，我并不是在雕刻这只石狮子，我是在唤醒它！” “唤醒？” “狮子本来就沉睡在石块中，我只是将他从石头牢笼中解救出来而已。” 一万次的灌输，不如一次真正的唤醒。","categories":[{"name":"代码之外","slug":"代码之外","permalink":"https://iamtaoxin.com/categories/%E4%BB%A3%E7%A0%81%E4%B9%8B%E5%A4%96/"}],"tags":[{"name":"日记","slug":"日记","permalink":"https://iamtaoxin.com/tags/%E6%97%A5%E8%AE%B0/"}]},{"title":"辞职，修路去 -- 我做编程这几年（三）","date":"2019-11-04T06:26:46.000Z","path":"2019/11/04/these-years-third/","text":"我对这座城市入了魔，曾经试图离开她，也离开了她，最后又鬼迷心窍般回到了这里，仿佛迷药已经侵蚀到了骨头里，稍有懈怠，你便会被一种无形的力量吞噬。 一、辞职 在这一年里，我做了很多事情，也学到了很多。我学习到了很多名词，但却杂乱无章，没有感觉到一丁点编程的乐趣；也领见识了勾心斗角，即使你不想参与任何一方的斗争，也仍然会被波及。在这一年，我的技术却没有任何进步，第一次感觉到迷茫，一年前也没有这般思考过自己。 看来，编程真的不适合我。 决定再三，我提交了辞呈，理由是不想再当程序员了，想做点有意义的事情，想转行，比如，去做建筑。 二、青海 只需一张火车票，就能把你从上海带到青海。一年前我由西向东，一年后我怀揣着梦想又离开了魔都。来的时候包里全是书，离开的时候我的包里装着七本建筑类的书籍，由此可见，我真的不想再做程序员了，已经做好了不再回去的打算。对于一个西北人来说，回到大西北是对自己莫大的安慰。海拔一米一米上升，我的呼吸却不是那么顺畅，仿佛已经习惯了低海拔的生活，在经过海拔一千五的兰州时，我的鼻子已经有点堵塞了。窗外的景色，变化了很多次，从一开始的绿色到后来的黄土色，远处的山上寸草不生，一眼望去，这便是苍凉的大西北。 三、路桥 朋友专业是土木，毕业之后也是做了建筑这一行，因此我也是寻他而来，在他的帮助下，我投身到了路桥事业。每天的工作便是领着一群藏族民工修路，读图纸量距离看数据…西宁的太阳很是毒辣，没过几天我俨然被晒成黑人一个，脸上也开始脱皮。 后来由于种种原因，在连续工作了一周之后，甚至连工钱都没有拿便愤然离去。 当然，这并不是心血来潮，可依然要为自己的抉择负责。 四、上班 记得是八月下旬到西宁的，然后租了房子，买了各种电器，开始了新的生活。可是，我的建筑生涯在七天之后就已经戛然而止。后来也连续找了其他工作，或是工资太低，或是做六休一…终于在一家汽车 4S 店找到了适合我的工作，在当时的西宁来说，我的工资已经不低了。而且因为我是毕业于财经类学校的缘故，财务也有想培养我做会计的想法，领导也让我去总部培训，好能够留下来。同事们也都待人不错，每天可以喝到同事磨好的咖啡，跟楼下的大爷聊聊天，看他写字听他拉二胡，日子过得也是不错，那是一段很有意义的工作。 五、离职 当我提出离职的时候，领导很是不舍，以至于在离职当天，他半开玩笑却也认真地说要撕掉我的离职申请，但他也清楚我的想法，随即放手。 六、初雪 离职的时候才十一月，可在当时的西宁，已经下起了雪，那应该是 15 年冬的初雪，落地即化。踩在地上，很快就会湿了鞋子。这一离去，貌似我在今后的四年里再没有经历过西北的第一场雪。","categories":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"https://iamtaoxin.com/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"}],"tags":[{"name":"我做编程这几年","slug":"我做编程这几年","permalink":"https://iamtaoxin.com/tags/%E6%88%91%E5%81%9A%E7%BC%96%E7%A8%8B%E8%BF%99%E5%87%A0%E5%B9%B4/"}]},{"title":"上海，我来了 -- 我做编程这几年（二）","date":"2019-10-30T15:13:29.000Z","path":"2019/10/30/these-years-second/","text":"在我眼里，上海是一个绝对公平的世界，在上海，你可以不用依靠家里人的关系去考试，也可以不用对上级察言观色拍马屁，更不用对别人唯唯诺诺低头哈腰；在上海，你只要通过你自己的努力就会得到回报，当然，不是所有的付出都会得到相应的回报，至少这些回报都是自己努力得来的… 一、世界杯 毕业那时，正值第 20 届世界杯，已经拿到双证的我，暂时在家养(hun)精(tian)蓄(du)锐(日)，在心仪的德国队拿到冠军奖杯的十多天后，我接到了一家公司的面试电话，第二天便背上行李只身前往上海。 二、在路上 记得当时还是站票，拖着沉甸甸两包纸质书的我，没有座位，我只能坐在过道的地上，来往的人从我腿上跨过，我无动于衷。火车轰隆轰隆前进着，车轮正向上海驶来，我抬头看着车门窗外一道道迅速后退的景色，脑袋里回想着自己最近一年的所为所为… 三、过去的一年 其实在大四这一年里，我也参加了不少工作的招聘，参加过某省安全局的招聘，参加过某地区边防武警的招聘，笔试体检体能各项皆合格，最后却没了音讯；也接到了某银行软件开发中心的面试通知；也拒绝过某个工作千把块薪水的国企也通过了某些面试笔试，最后都以各种原因而告终… 四、黑兰州和中性笔 “不好意思，收一下脚，让一让…”，随着声声吆喝，我的思绪被拉回了现实，立马站起身来，提起自己的行李好让他人通过，掏出手机看了下时间，24 个小时的车程居然才过了四分之一。兜里揣着一包兰州，其实我并不喜欢抽烟，只是想在没有头绪的时候，抽一支烟来假装自己在思考，这时想抽一支，发现另一个兜里没有火，掏出来的反而是一直中性笔。随身揣着一支笔，是因为自己从小就有写日记的习惯，文采不咋滴，但是每天写写流水账还是可以的。或许，可能 “装笔” 这个词就是因此而来吧，嘿嘿 五、第一份工作 一家很小的公司，我以软件程师的身份（实际上是个打杂的）入职了这里。上班的第一天便被外包到了一家银行里工作，在没有任何人指导的情况下我完成了第一个项目的升级和二次优化，其实那时并不是第一次接触 C#，也并非第一次开发应用程序，实习的时候我就独立完成过某项目的开发。这里的同事比较温和更有礼貌，偶尔也会和他们一起去打打台球踢踢足球，在银行度过了两三个月，完成了自己的任务之后，回到了公司的办公室工作。从此开始了我的全干生涯，开始写 PHP、Android、Java、VB、JavaScript 等，早上还在写 PHP 项目，下午一个会议就得投入到 Angular 当中… 在那一年，我做了不少事情，也学到了很多","categories":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"https://iamtaoxin.com/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"}],"tags":[{"name":"我做编程这几年","slug":"我做编程这几年","permalink":"https://iamtaoxin.com/tags/%E6%88%91%E5%81%9A%E7%BC%96%E7%A8%8B%E8%BF%99%E5%87%A0%E5%B9%B4/"}]},{"title":"那年，我大三 -- 我做编程这几年（一）","date":"2019-10-29T10:12:39.000Z","path":"2019/10/29/these-years-first/","text":"“还愣在这干嘛？赶紧回去写退学申请，十二点之前必须写好交给我！”班主任冰冷地说道，不带有一点表情，我心里也觉得看来他让我退学这事儿是势在必得了。 事情还得从头说起，一切的源头其实都是因为自己没有好好读书，才至于考了一个渣渣二本。2010 年夏，对于这个学校这个专业，我是拒绝的，从高考结束那一天，我就想着补习一年，也想着把自己过去的不努力都给补上。 开学那天，我是自己拎着包从老家到兰州去，别人孩子都是父母陪同前来报名，我独自一人的原因是根本不想来这个学校。 … 就这样，喝酒和睡觉占用了我前两年的大学时光。 回到开头退学申请的事情，仅仅是因为连续两次翘课，就被班主任叫到办公室劈头盖脸一顿骂，然后叫嚷着让我必须退学。当时已经大三，对于自己来说，考研，靠公务员都不是自己心里想要的出路，说实话也没有想到要去做编程。其实大学的课程有 C、Java 之类的编程课，对这些倒也感兴趣。后来校内有 Java 编程 培训班，正好就报了名，想想就算以后不做编程，扫扫盲也是可以，至少自己是比较热爱计算机的。 对于自己热爱计算机，我是这么定义的。从小我就是一个不安分的孩子，喜欢拆东西，拆电脑手机，游戏机 Mp3…甚至连电热毯的开关也要拆开研究研究其中的原理，拆开之后通上电，然后就第一次体验到了电流穿身而过的感觉。 当时报班学习 Java，是因为想到自己不喜欢应试教育，不想再继续考啊考；不想考公务员，可能是觉得自己学习能力差吧，没法走到最后一关，后来正巧听到培训的消息，起初也没有投入太大的热情，仅仅是奔着扫盲和多个一技之长去的。当时的学费也挺贵的，还是朝家里伸手要钱，想尽了各种理由说服家里打来学费。 对计算机基础不错的我来说，学习起来并不吃力。每天至少有两个小时是在学习编程，周末是整天上课，因此在其他课程上的投入也相对少了些。 说起学习的结果来，其实收货还算蛮大的，至少编程规范方面，养成了我代码洁癖的习惯，而且当时主要是学习后端， DIV + CSS 的 HTML 页面对我来说，是最难理清的，以至于工作后的一年多时间里，对前端一直提不起兴趣来，在上课的过程中，也合其他同学合作开发了几个项目，在那时我才理解了团队的力量，一个人再优秀，永远发挥不出团队那样的能量，学会融入团队，学会扬长避短，才能塑造更好地自己。 大三的时光是由 Java 伴随着我，当然里面也有一些插曲，13 年夏初，接到了某航的飞行员面试电话，当时对于飞行员这个行业我是拒绝的，只有一个原因，那就是我恐高。现在想想，脑袋真的是有个偌大的坑。 在暑假学完了最后的课程（居然是 Oracle 和 Android），升入到了大四，最后的欢乐时光~。 _回想起来，命运真的是捉弄人，原来我大三的时候我已经踏上编程这条 “不归路”_。","categories":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"https://iamtaoxin.com/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"}],"tags":[{"name":"我做编程这几年","slug":"我做编程这几年","permalink":"https://iamtaoxin.com/tags/%E6%88%91%E5%81%9A%E7%BC%96%E7%A8%8B%E8%BF%99%E5%87%A0%E5%B9%B4/"}]},{"title":"坚持跑步的一些理由","date":"2019-10-07T16:00:00.000Z","path":"2019/10/08/why-run/","text":"跑步是最古老、最纯洁、最简单的运动：亚当和夏娃在伊甸园中追逐嬉戏，非洲土著每天行走 10 英里狩猎，马拉松让世界记住了 1896 年的在希腊举行的首届现代奥林匹克运动会。这些都和跑步有关。 当然，跑步也带来了很多的好处： 你不需要任何指导手册就可以跑：如果你能走，你就能跑。 跑步可以让你精力更旺盛：一次合理的跑步训练会让你干其他的事情也都充满活力。 跑步的时候还可以干些其他的事情：听音乐、听文章、冥思等。 跑步可以提升你的创造力：当你思维陷入停滞，当你不得不做个很重要的决定时，跑步可以帮你理清思路，恢复你的思维活力。 跑步是一种积极的“嗜好”，它只会让你更健康、更快乐！而其他嗜好（烟、酒、暴食）的效果却相反。 跑步是最好的朋友，在你需要时，它随时在你身边，非常可靠，只要你想和“它”见面，你就可以见到它。 跑步可以提高你的时间管理能力：只要你把跑步时间安排好，其他事情可在跑步前还是跑步后做，你就能够很好的计划了。 跑步可以让你设立目标，并实现它：只要你有目标，努力去实现它，你就会有满足感。无论这个目标有多小，都比没有目标，让你的生活更充满渴望。 跑步是最好的方式了解一个新的城市：出差或是什么原因来到一个新的城市，跑在一个陌生的地方，会让你别有一番感受。 跑步让你更年轻。 跑步让你很兴奋：虽然不是每次跑步训练都会让你感觉到亢奋，但是经常性的兴奋感受足以回报你艰苦的训练过程。 跑步有助于提高自信心和保持自尊。 跑步会让你的身体有规律的运转。 跑步让你生活的更有效率。 跑步有助于睡眠。 跑步能使你更聪明：研究表明，跑步有助于提高你的记忆力。 每次跑步都是一次不同的经历，当你系上鞋带，你今天迈出的每一步会和昨天是不同的，你所见所想，也会不同。每天都经历不同，多开心的一件事啊！ 所以，跑起来吧！","categories":[{"name":"个人提升","slug":"个人提升","permalink":"https://iamtaoxin.com/categories/%E4%B8%AA%E4%BA%BA%E6%8F%90%E5%8D%87/"}],"tags":[{"name":"运动健身","slug":"运动健身","permalink":"https://iamtaoxin.com/tags/%E8%BF%90%E5%8A%A8%E5%81%A5%E8%BA%AB/"}]},{"title":"Babel 入门教程","date":"2019-07-07T16:00:00.000Z","path":"2019/07/08/about-babel/","text":"作用：将 ES6+ 版本的代码转换为 ES5代码，以便能够运行在当前环境和旧版浏览器环境中。 这就意味着，可以用 ES6 编写代码，而不用担心当前环境是否支持的问题。 一、配置 .babelrc使用 Babel的第一步，就是配置 .babelrc 这个文件，该文件存放在项目根目录下，用来设置转码规则和插件，基本格式如下： &#123; \"presets\": [...], \"plugins\": [...] &#125; 其中 presets 字段设定转码规则，可根据需要安装。 # ES2015转码规则 $ npm install —save-dev babel-preset-es2015 # react转码规则 $ npm install —save-dev babel-preset-react # ES7不同阶段语法提案的转码规则（共有4个阶段），选装一个 $ npm install —save-dev babel-preset-stage-0 $ npm install —save-dev babel-preset-stage-1 $ npm install —save-dev babel-preset-stage-2 $ npm install —save-dev babel-preset-stage-3 然后将这些规则加入 .babelrc: &#123; \"presets\": [ \"es2015\", \"react\", \"stage-2\" ], \"plugins\": [...] &#125; 二、命令行转码 babel-cliBabel 提供 babel-cli 工具，用于命令行转码。 安装命令如下： $ npm install --global babel-cli 基本用法如下： # 转码结果输出到标准输出 $ babel example.js # 转码结果写入一个文件 # --out-file 或 -o 参数指定输出文件 $ babel example.js --out-file compiled.js # 或者 $ babel example.js -o compiled.js # 整个目录转码 # --out-dir 或 -d 参数指定输出目录 $ babel src --out-dir lib # 或者 $ babel src -d lib # -s 参数生成source map文件 $ babel src -d lib -s 以上代码是在全局环境下安装的，存在两个问题： 如果项目要运行，全局环境必须有 Babel，也就是说项目对环境产生了依赖。 全局安装 Babel，无法支持不同项目使用不同版本的 Babel。 针对上述问题，解决的办法是将 babel-cli 安装在项目之中。 # install $ npm install -save-dev babel-cli 然后，改写 package.json。 &#123; // … “devDependencies”: &#123; “babel-cli”: “^6.0.0” &#125;, “scripts”: &#123; “build”: “babel src -d lib” &#125;, &#125; 转码的时候，执行$ npm run build 命令即可。 三、babel-nodebabel-cli 工具自带一个 babel-node 命令，提供一个支持 ES6 的 REPl环境。它支持 Node的REPL环境的所有功能，而且可以直接运行ES6代码。 $ babel-node > (x => x * 2)(1) babel-node 命令可以直接运行ES6脚本。将上面的代码放入脚本文件 es6.js，然后直接运行。 $ babel-node es6.js 2 babel-node 也可以安装在项目中。 $ npm install --save-dev babel-cli 然后改写 package.json。 &#123; \"scripts\": &#123; \"script-name\": \"babel-node script.js\" &#125; &#125; 上面的代码中，使用 babel-node 替代 node， 这样 script.js 本身就不用做任何转码处理。 四、babel-registerbabel-register 模块改写 require 命令，为它加上一个钩子。此后，每当使用 require 加载 .js 、.jsx 、 .es 和 .es6 后缀名的文件，就会先用 Babel进行转码。 $ npm install -save-dev babel-register 使用时，必须首先加载 babel-register。 require(\"babel-register\"); require(\"./index.js\"); 然后就不需要手动对 index.js 转码了。 需要注意的是， babel-register 只会对 require 命令加载的文件转码，而不会对当前文件转码。另外它是实时转码，所以只适合在开发环境使用。 五、babel-core如果某些代码需要调用到Babel的API进行转码，就需要使用 babel-core 模块。 安装命令如下： $ npm install babel-core --saves 然后，在项目中就可以调用 babel-core。 var babel = require(\"babel-core\"); // 字符串转码 babel.transform('code();', options); // => &#123; code, map, ast&#125; // 文件转码 (异步) babel.transformFile('filename.js', options, function(err, result) &#123; result; // => &#123;code, map, ast&#125; &#125;); // 文件转码（同步） babel.transformFileSync('filename.js', options); // => &#123;code, map, ast&#125; // Babel AST转码 babel.transformFromAst(ast, code, options); // => &#123; code, map, ast &#125; 配置对象 options,可以参看官方文档 http://babeljs.io/docs/usage/options/ 。 下面是一个例子。 var es6Code = 'let x = n => n + 1'; var es5Code = require('babel-core') .transform(es6Code, &#123; presets: ['es2015'] &#125;) .code // '\"use strict\";\\n\\nvar x = function x(n) &#123;\\n return n + 1;\\n&#125;;' 上述代码中， transform 方法的第一个参数是字符串，标识需要转换的ES6代码，第二个参数是转换的配置对象。 六、babel-polyfillBabel默认制转换新的JavaScript句法(syntax)，而不转换新的API，比如Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise等全局对象，以及一些定义在全局对象上的方法（比如 Object.assign）都不会转码。 举例来说，ES6在 Array 对象上新增了 Array.from 方法。 Babel就不会转码这个方法。如果想让这个方法运行，必须使用 babel-polyfill,为当前环境提供一个垫片。 安装命令如下： $ npm install --save babel-polyfill 然后，在脚本头部，加入如下代码： import 'babel-polyfill'; // 或者 require('babel-polyfill') 七、浏览器环境Babel也可以用于浏览器环境。但是，从Babel 6.0开始，不再直接提供浏览器版本，而是要用构建工具构建出来。如果你没有或者不想使用构建工具，可以通过安装5.x版本的 babel-core 模块获取。 $ npm install babel-core@old 运行上面的命令以后，就可以在当前目录的 node_modules/babel-core子目录里面，找到babel 的浏览器版本browser.js和browser.min.js。 然后，将下面代码插入网页： &lt;script src=\"node_modules/babel-core/browser.js\">&lt;/script> &lt;script type=\"text/babel\"> // Your ES6 code &lt;/script> 上面代码中，browser.js 是Babel提供的转换器脚本，可以在浏览器运行。用户的ES6脚本放在 script标签之中，但是要注明 type=&quot;text/babel&quot;。 另一种方法是使用 babel-standalone 模块提供的浏览器版本，将其插入网页。 &lt;script src=\" [https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/6.4.4/babel.min.js](https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/6.4.4/babel.min.js) \">&lt;/script> &lt;script type=\"text/babel\"> // Your ES6 code &lt;/script> 注意：网页中实时将ES6代码转为ES5，对性能会有影响。生产环境需要加载已经转码完成的脚本。 下面是如何将代码打包成浏览器可以使用的脚本，以 Babel 配合 Browserify 为例。首先，安装 babelify 模块： $ npm install --save-dev babelify babel-preset-es2015 然后，再用命令行转换ES6脚本： $ browserify script.js -o bundle.js \\ -t [babelify --presets [ es2015 react] ] 上面代码将ES6脚本 script.js，转为 bundle.js，浏览器直接加载后者就可以了。 在 package.json 设置下面的代码，就不用每次命令行都输入参数了。 &#123; \"browserify\": &#123; \"transform\": [[\"babelify\", &#123;\"presets\": [\"es2015\"]&#125;]] &#125; &#125; 八、与其他工具配合这里举两个例子：ESLint和Mocha。 ESLint 用于静态检查代码的语法和风格，安装命令如下： $ npm install --save-dev eslint babel-eslint 然后，在项目根目录下，新建一个配置文件.eslint，在其中加入parser字段。 &#123; “parser”: “babel-eslint”, “rules”: &#123; … &#125; &#125; 再在 package.json 之中，加入相应的scripts 脚本。 &#123; \"name\": \"my-module\", \"scripts\": &#123; \"lint\": \"eslint my-files.js\" &#125;, \"devDependencies\": &#123; \"babel-eslint\": \"...\", \"eslint\": \"...\" &#125; &#125; Mocha 则是一个测试框架，如果需要执行使用ES6语法的测试脚本，可以修改package.json 的scripts.test。 \"scripts\": &#123; \"test\": \"mocha —ui qunit —compilers js:babel-core/register\" &#125; 上面命令中， --compilers 参数指定脚本的转码器，规定后缀名为 js 的文件，都需要使用 babel-core/register先转码。 文章摘自： http://www.ruanyifeng.com/blog/2016/01/babel.html","categories":[{"name":"技术整理","slug":"技术整理","permalink":"https://iamtaoxin.com/categories/%E6%8A%80%E6%9C%AF%E6%95%B4%E7%90%86/"}],"tags":[{"name":"Babel","slug":"Babel","permalink":"https://iamtaoxin.com/tags/Babel/"}]},{"title":"2019年书单","date":"2019-04-14T08:33:08.000Z","path":"2019/04/14/2019-books/","text":"每一年都做了很多计划，比如技术上有所长进，能进入大厂；又或者是去旅游几次，行万里路；亦或每天健身锻炼，练就一身腱子肉；也想每天坚持写作，即使是记流水账，也要把心中所想目中所见手中所得一一列举在这纸上。然鹅最后，无一不是以失败而告终，回到想想，坚持确实是世界上最难的事情。 这次，又计划“读万卷书”，[捂脸.jpg]。 商业的本质 你的善良必须有点锋芒 成为乔布斯 鬼谷子的局 山海经密码 野性的呼唤 穷爸爸富爸爸 素数之恋 编译原理 区块链核心算法 刻意练习 墨菲定律 巨人的陨落 每天学点管理学 自控力 原则 爱与数学 数学之美 大秦帝国 增长黑客 浮生六记 仓央嘉措 废都 白话大数据与机器学习 人人都是产品经理 未来简史 时间简史 人类简史 你不知道的 JavaScript（上） 你不知道的 JavaScript（中） 你不知道的 JavaScript（下） JavaSrcipt 设计模式 JavaScript 数据结构与算法","categories":[{"name":"个人提升","slug":"个人提升","permalink":"https://iamtaoxin.com/categories/%E4%B8%AA%E4%BA%BA%E6%8F%90%E5%8D%87/"}],"tags":[{"name":"打脸的Flag","slug":"打脸的Flag","permalink":"https://iamtaoxin.com/tags/%E6%89%93%E8%84%B8%E7%9A%84Flag/"}]},{"title":"记第一次半马","date":"2018-11-29T10:50:15.000Z","path":"2018/11/29/yangpu-marathon/","text":"其实我也算是个比较热爱跑步的人吧，线上的比赛也参加了不少，从一开始的 5KM 到 后来的 10KM 或者 20KM，无聊的时候也会去操场刷刷圈。 但是对于线下的马拉松比赛，这竟然是第一次参加。其实并非第一次想跑线下，究其原因，本来是报了各种线下比赛，奈何一次中签都没有[无奈.png]，可能还是由于自己的跑量不够多吧。 由于在杨浦区居住过小一年时间，所以对杨浦的印象还是蛮好的，老城区，环境好，小区旁边就是杨体，早晚都回去那边跑跑步，因此也认识了一群跑步的前辈们，跟他们比起来，我就是个跑渣。 对于这次比赛，我和基友两个人还是比较看重的，毕竟我俩是第一回参加嘛，所以提前一周就订好了酒店，比赛前一天晚上住在那边。 这次比赛的起点是在新江湾城耐克大中华区总部那边，十一月底的申城早上还笼罩着一层雾气，但是这毫不影响大家跑步的热情，上午 7 时，鸣枪开跑 🏃。 虽然之前也跑了不少的线上赛，至少一个人跑步可以控制稳定的步频和配速，但是到了线下，当鸣枪之后，所有人都在往前冲的时候，似乎也忘记了自己的配速。一开始的时候跟小伙伴商量好，要控制配速，确实在比赛伊始，是跟着 230 的兔子在跑，后来随着人流，也就慢慢加快了速度。过程中，有好几个艰难的阶段，有点像放弃的念头，好在最后还是坚持完赛了。 比赛的终点设在了复旦大学江湾校区，对于我自己来说，第一次跟复旦见面的情景居然是拖着沉重的脚步跑进校园里[😆]。 写在最后: 关于坚持。这辈子最难做的事情可能就是坚持。坚持运动，坚持阅读，坚持写作，坚持早起，坚持做对的事情…少则坚持一月，长则一年十年，坚持就是最好的习惯。","categories":[{"name":"个人提升","slug":"个人提升","permalink":"https://iamtaoxin.com/categories/%E4%B8%AA%E4%BA%BA%E6%8F%90%E5%8D%87/"}],"tags":[{"name":"运动健身","slug":"运动健身","permalink":"https://iamtaoxin.com/tags/%E8%BF%90%E5%8A%A8%E5%81%A5%E8%BA%AB/"}]},{"title":"区块链学习笔记","date":"2018-06-14T08:45:45.000Z","path":"2018/06/14/blockchain-note/","text":"区块链是个天然和钱离得很近的领域，离钱越近就越容易赚到钱，尽早开始准备并在区块链领域站稳脚跟的人将能享受到行业崛起的巨大红利，就像四年前的微信公众号，两年前的知识付费，一年前的微信小程序。 参考来源: 区块链开发入门：从 0 到 1 构建基于以太坊智能合约的 ICO DApp 一、账户、交易、区块、区块链是什么？ - **账户** (Account) 使用户在银行的户头+密码的组合，在区块链世界中也是如此，不论是比特币还是以太坊的账户都是由地址、公钥、私钥这3部分构成的，其中地址相当于用户名，而公钥+私钥相当于密码，尤其是私钥，丢失或者泄露就意味着失去账户的控制权； * **交易** (Transaction) 是账户中的任意一直收支记录，在区块链世界中可以指两个账户之间的转账交易、或者只能合约调用请求； * **区块** (Block) 是账本中的一页，账本的每页可能包含多笔收入和支出，同样，区块链中的每个区块都可能包含多笔交易； * **区块链** (Blockchain) 是装订成册的多页账本，账本不同页按照记录时间先后顺序组织，区块链中不用区块按被矿工打包的时间先后组织。 二、关于以太坊网络 * 整体视角，以太坊网络本质是 P2P 网络系统，其用途是发起交易、存储交易历史，这里的交易可以是转账或者是调用只能合约中的方法，而以太坊区块链则是存储了以太坊网络上发生过的每笔交易的数据库。常说的以太坊网络通常情况下是指主网，实际上社区中存在很多用途各异的以太坊网络，类比到 Web 开发工程里面 3 套环境，可将其归类如下： - **主网**： Mainnet，就是以太坊的 `线上环境`，记录、保存用户和只能合约的交易，主网中存储的代币才具有真正的价值； - **测试网**： Testnet，以太坊的 `测试环境`，目的是方便社区和开发者测试智能合约、转账等功能，典型的测试网络有 `Rinkeby` 、 `Ropsten` 、 `Kovan` 等，其中的代币不具有任何价值； - **其他网**： 以太坊的 `开发环境`，常通过开发者在本地运行以太坊节点组成，或者使用各种便捷的工具启动的本地测试网，以及以内部测试为目的而搭建的私有网络等。 * **个体视角**， P2P 网络通畅包含多个节点，每个节点都需要运行以太坊客户端，而任何人都可以运行以太坊节点，每个以太坊网络上的节点都包含了以太坊区块链数据库的整体副本，每个以太坊网络节点都可以接收 RPC 交易请求并将请求广播给网络中的其他节点，每个以太坊节点都会尝试进行交易的校验、打包（常说的挖矿），即区块生产的任务，生产出的区块也会被广播给其他网络节点。 注意： 以太坊不同网络之间的账户可以完全相同，就好比我们可以把线上数据库中的数据全部同步到测试环境数据库一样，但是不同测试网络之间、测试网络和主网之间、本地开发网络和主网之间是完全隔离的，即无法进行转账和智能合约功能调用。","categories":[{"name":"技术整理","slug":"技术整理","permalink":"https://iamtaoxin.com/categories/%E6%8A%80%E6%9C%AF%E6%95%B4%E7%90%86/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://iamtaoxin.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"前端面试之HTML篇","date":"2018-06-12T23:49:47.000Z","path":"2018/06/13/fe-interview-html/","text":"1. CSS 三列布局常用的实现方案（左右定宽，中间自适应） 圣杯布局 Holy Grail Layout原理：利用 CSS 负边距(Negative Margin)强行将左右两边的 DIV 移动到 中间 DIV 的左右。 &lt;body> &lt;div class=\"container\"> &lt;div class=\"middle\">&lt;/div> &lt;!-- 先渲染middle --> &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;div&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation attr-equals&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;left&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;div&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;div&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation attr-equals&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;right&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;div&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt; &lt;/div&gt;&lt;/body&gt;:hexoPostRenderEscape–&gt; 相应的 style 如下 ：.container &#123; padding: 0 200px; &#125; .container > div &#123; height: 200px; float: left; &#125; .middle &#123; width: 100%; background: blue; &#125; .left &#123; margin-left: -100%; position: relative; left: -200px; width: 200px; background: red; &#125; .right &#123; margin-left: -200px; /* 用 -200px 吃掉 .right 自己的宽度 */ position: relative; /* 相对 .container -200px */ right: -200px; width: 200px; background: green; &#125; 双飞翼布局 &lt;body> &lt;div class=\"container\"> &lt;div class=\"middle\"> &lt;div class=\"middle-container\">&lt;/div> &lt;/div> &lt;div class=\"left\">&lt;/div> &lt;div class=\"right\">&lt;/div> &lt;/div> &lt;/body> 相应的 style 如下 ： .container > div &#123; float: left; height: 200px; &#125; .middle &#123; width: 100%; background: red; &#125; .middle-container &#123; /* 添加 .middle-container 包裹内容 */ height: 200px; margin: 0 200px; background: darkred; &#125; .left &#123; width: 200px; margin-left: -100%; background: blue; &#125; .right &#123; width: 200px; margin-left: -200px; background: green; &#125; Flex 布局 &lt;body> &lt;div class=\"container\"> &lt;div class=\"col-1\">&lt;/div> &lt;div class=\"col-2\">&lt;/div> &lt;div class=\"col-3\">&lt;/div> &lt;/div> &lt;/body> 相应的 style 如下 ：.container &#123; display: flex; width: 100%; &#125; .container > div &#123; height: 100px; border: 1px solid #000; flex: 1; position: relative; &#125; 2. CSS 如何实现垂直居中？ 父标签上指定高度 (height) 与行度 (line-height)相同即可： &lt;body> &lt;div class=\"vertical\">&lt;/div> &lt;/body> 相应的 style 如下 ：html, body &#123; width: 100%; height: 100%; margin: 0; padding: 0; &#125; .vertical &#123; width: 100px; height: 100px; background: red; margin: 0 auto; /* 最简单的水平居中方式 */ /* 以下是垂直居中的代码： */ position: relative; top: 50%; margin-top: -50px; &#125; 使用 Flex Layout 中的 align-items 和 justify-content 实现居中 &lt;body> &lt;div class=\"vertical\">&lt;/div> &lt;/body> 相应的 style 如下 ：html &#123; height: 100%; width: 100%; &#125; body &#123; /* 使用 CSS3 flex layout 使元素垂直居中 */ display: flex; align-items: center; justify-content: center; margin: 0; padding: 0; height: 100%; &#125; .vertical &#123; width: 100px; height: 100px; background: red; &#125; &gt; &lt;span style=&quot;color:orange&quot;&gt;注：但是这种方法存在兼容性问题，下图是各个浏览器的支持情况：&lt;/span&gt; Flex 教程可参考 Flex 布局教程:语法篇","categories":[{"name":"个人笔记","slug":"个人笔记","permalink":"https://iamtaoxin.com/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"html","slug":"html","permalink":"https://iamtaoxin.com/tags/html/"}]},{"title":"使用 Node.js + Nginx 部署 HTTPS","date":"2018-06-08T08:13:33.000Z","path":"2018/06/08/node-js-nginx-https/","text":"具体步骤： 安装证书&lt;!–hexoPostRenderEscape:$ sudo apt-get update$ sudo apt-get install software-properties-common$ sudo add-apt-repository ppa:certbot/certbot$ sudo apt-get update$ sudo apt-get install python-certbot-nginx $ sudo certbot --nginx certonly:hexoPostRenderEscape–&gt; nginx 反向代理在 /ete/nginx/site-available/default 中:location /api &#123; proxy_pass http://localhost:8089; proxy_buffering on; &#125; 重启 nginx，重启 node。","categories":[{"name":"技术整理","slug":"技术整理","permalink":"https://iamtaoxin.com/categories/%E6%8A%80%E6%9C%AF%E6%95%B4%E7%90%86/"}],"tags":[{"name":"服务器部署","slug":"服务器部署","permalink":"https://iamtaoxin.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2/"}]},{"title":"谈谈前端优化","date":"2018-05-27T14:32:47.000Z","path":"2018/05/27/front-end-optimization/","text":"一、优化的原则和方向1.1 前端性能优化的原则其实就是更好的用户体验，具体实现的目标大体有两个： 合理使用内存或缓存，减少请求； 减少 CPU 或 GPU 的计算，达到更快的展现。 1.2 前端在性能优化的方向大致有两个： 减少页面体积，提升网络加载; 优化页面渲染 二、方向详情2.1 较少页面体积，提升网络加载 静态资源的压缩合并（JS 代码压缩合并、 CSS 代码压缩合并、雪碧图） i. 压缩是为了减小文件的体积，减轻网络负载，达到更快的下载; ii. 合并和雪碧图都是为了减少文件的请求次数，但不是合并的就一定比没有合并时加载快，要考虑合并之后的体积，若文件合并之后太大也不利于性能优化，所以在实际项目中要做好权衡。 静态资源缓存（资源名称加 MD5 戳） i. 可以通过链接名称控制缓存： 通过前端构建工具为打包的文件添加 MD5 后缀，这样当打包上线时请求的链接将发生改变，可以防止由于缓存导致静态资源更新失效； 使用 CDN 让资源加载更快 2.2 优化页面渲染 CSS 放在头部， JS 放后面 浏览器在渲染解析过程中，若遇到 &lt;link href=&quot;...&quot;&gt; 和 &lt;script src=&quot;...&quot;&gt; 这种外链加载 CSS 和 JS 的标签，浏览器会异步下载并解析执行。 CSS 放在头部是为了让浏览器今早解析执行 CSS 文件，渲染出页面的样式，若放在底部会出现渲染卡顿的情况，影响性能和体验。 而当渲染过程中遇到 script 标签时就会执行 JS 代码，从而阻塞页面渲染，因为浏览器渲染和 JS 执行共用一个县城，而且这里必须是单线程操作，多线程会产生渲染 DOM 冲突。所以要将 JS 放在底部，等到页面渲染完成之后再去解析执行 JS，保证用户体验性。 另外，JS 执行如果涉及 DOM 操作，得等待 DOM 解析完成才行，JS 放在底部执行是，HTML 肯定都解析成了 DOM 结构。 JS 如果放在 HTML 顶部，JS 执行的实行 HTML 还没来得及转换为 DOM 结构，可能会引起报错。 懒加载（图片来加载、下拉加载更多） i. 先将 src 赋值成一个通用的浏览图，下拉的时候再动态赋值成正式的图片。通用的预览图可以是体积比较小的，这样加载会很快，待页面下拉，图片显示出来时，再去替换 src 为 data-src 的值。（ data- 开头的属性浏览器渲染的时候会忽略掉，提高渲染性能）&lt;img src=\"preview.png\" data-src=\"realImg.png\" /> 减少 DOM 查询，对 DOM 查询做缓存，代码如下： // 只查询一个DOM，缓存在 pList 中了 var pList = document.getElementsByTagName('p'); for(var i = 0; i &lt; pList.length; i++)&#123; &#125; //每次循环，都会查询 DOM，耗费性能 for(var i = 0; i &lt; document.getElementsByTagName('p').length; i++)&#123; &#125; 减少 DOM 操作，多个操作尽量合并在一起执行 （DocumentFragment） DOM 操作是非常耗费性能的，因此插入多个标签时，先插入 Fragment 然后再统一插入 DOM。因为 Fragment 文档片段存在于内存中，并不在 DOM 树中，所以将子元素插入到文档片段时不会引起页面回流。 事件节流 i. 防抖 ii. 节流 尽早执行操作 window.addEventListener('load', function()&#123; // 页面的全部资源加载完才会执行，包括图片、视频等 &#125;) document.addEventListener('DOMContentLoaded', function()&#123; // DOM 渲染完成即可执行，此时图片、视频等资源可能没有加载完成 &#125;) $(document).ready(function()&#123; // 同 DOMContentLoaded &#125;) 使用 预渲染 或者 SSR服务端渲染，数据直接输出到 HTML中，减少浏览器使用 JS 模板渲染页面 HTML 的时间，同时也有利于网站的 SEO。","categories":[{"name":"技术整理","slug":"技术整理","permalink":"https://iamtaoxin.com/categories/%E6%8A%80%E6%9C%AF%E6%95%B4%E7%90%86/"}],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"https://iamtaoxin.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]},{"title":"前端面试基础之JavaScript篇","date":"2018-05-20T09:27:00.000Z","path":"2018/05/20/fe-interview-js/","text":"I. 说说 JS 的数据类型1.1 基本类型 String Number Boolean null undefined symbol (ES6 中新增) 1.2 引用类型 Date RegExp Object Array Function ( 后三种为基本包装类型，特殊的引用类型，也算作基本类型) 1.3 基本类型保存在栈上，引用类型的引用保存在栈上，其对象保存在堆中。1.4 null 和 undefined 的区别？- i. 含义不同：`null` 表示该处不该有值，而 `undefined` 表示该处有值，但还没有进行初始化 - ii. 类型不同： `null` 的类型为 `Object`, `undefined` 的类型为 `undefined`II. 变量提升III. 对于闭包的理解，以及在什么场景下会使用到闭包？3.1 什么是闭包？闭包是指那些可以访问独立数据的函数。 function init() &#123; let name = \"Mozilla\"; // name 是一个被 init创建的局部变量 function displayName() &#123; // displayName() 是一个内部函数 alert(name); // 一个闭包使用在父函数中声明的变量 &#125; displayName(); &#125; 这段代码中，displayName 是一个典型的闭包，它能够访问它之外的 name 变量，并保存这个变量在它创建时的状态。这个特性非常实用，因为 Javascript 有很多奇怪的坑 IV. 谈谈对原型与原型链的了解度，有几种方式可以实现继承，用原型实现集成有什么缺点，要怎么解决？4.1 什么是原型链？原型链是 Javascript 实现继承最重要的一种方式。每一个对象都有自己的原型对象，根原型对象没有原型，所以其 __proto__ 属性值为 null 。在调用时，如果访问的对象属性没有找到，Javascript 会顺着原型链继续往下找，直到触碰到根原型为止。 4.2 原型与原型链的区别是什么？__proto__ 是隐式原型，指向创建这个对象的函数(constructor) 的 prptotype，用来构成原型链和实现基于原型的继承。 protype 是显式原型，用来实现基于原型的继承与属性的共享。每一个函数都具有 prototype 属性。 4.3 在面向对象语言中，继承分为两种： 接口集成：只集成方法签名 实现集成：继承实际的方法 因为 Javascript 没有继承的关键字，所以 JS 实现继承的方法很特殊，大概有以下几种： 原型链继承(最常见)： var Base &#x3D; function ()&#123; this.name &#x3D; &#39;Base&#39;; this.toString &#x3D; function ()&#123; return this.name; &#125; &#125; var Sub &#x3D; function ()&#123; Base.call(this); this.name &#x3D; &#39;Sub&#39;; &#125; 这种继承解决了原型链继承的问题，但它也有一些弊端：使用 instanceof 运算符的时候会发现，它的实例并不是父类的实例（因为父类并没有在它的原型链上）。 实例继承 var Base &#x3D; function ()&#123; this.name &#x3D; &#39;Base&#39;; this.toString &#x3D; function ()&#123; return this.name; &#125; &#125; var Sub &#x3D; function()&#123; var instance &#x3D; new Base(); instance.name &#x3D; &#39;Sub&#39;; return instance; &#125; 这种继承方法只能强行被归类为继承，因为它实际上是返回了一个父类的实例，与子类毫无关系。同样，这种方法也不支持多继承。 拷贝继承 var Base &#x3D; function ()&#123; this.name &#x3D; &#39;Base&#39;; this.toString &#x3D; function ()&#123; return this.name; &#125; &#125; var Sub &#x3D; function ()&#123; var base &#x3D; new Base(); for(var i in base)&#123; sub.prototype[i] &#x3D; base[i]; &#125; sub.prototype[&#39;name&#39;] &#x3D; &#39;Sub&#39;; &#125; 首先，只有可枚举的对象类型才能使用 foreach 的方式获取到。它的优点是可以实现多继承，缺点是不方便写，效率低。 V. iframe 的缺点有哪些？VI. Ajax 的原生写法VII. 为什么会有同源策略VIII. 前端解决跨域的几种方式IX. 怎么判断两个对象是否相等X. 代码实现一个对象的深拷贝XI. 从发送一个 url 地址到返回页面内容，中间发生了什么？XII. 前端性能优化了解多少","categories":[{"name":"个人笔记","slug":"个人笔记","permalink":"https://iamtaoxin.com/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://iamtaoxin.com/tags/JavaScript/"}]},{"title":"使用axios发送POST请求时后端获取不到参数的问题","date":"2018-05-18T09:21:39.000Z","path":"2018/05/18/axios-post/","text":"在使用 vue2 + axios + node.js + express 开发管理后台时，遇到了axios发送POST请求时后端获取不到参数的问题 ，查阅资料许久，还是未找到解决办法，无奈之下，喝一口凉水，歇息一番，继续寻求良方。 终于，皇天不负有心人，在这里，还是找到了解决的办法。 axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded'; 由此看出，axios 在 POST 提交数据时也是使用的这种方式，在 java 和 php 可以获取到对应的 request 原始流数据获取到对应的值并将其序列化. 但是这样的方式在 express 服务后端并不能获取到数据，因此 express 中使用的是 body-parser 去格式化前台传来的数据，具体实现看代码： //server 'use strict' var express = require('express') var powerexpress = require('power-express')(express) var authority = require('./filter/authority') var app = powerexpress() // 使用 body-parse 格式化数据 var bodyParser = require('body-parser') app.use(bodyParser.urlencoded(&#123; extended: true &#125;)) app.use(bodyParser.json()) var Server = require('./server') var cookieParser = require('cookie-parser') app.use(cookieParser()) require('./controllers/routes')(app) var appServer = new Server(app) appServer.start()","categories":[{"name":"技术整理","slug":"技术整理","permalink":"https://iamtaoxin.com/categories/%E6%8A%80%E6%9C%AF%E6%95%B4%E7%90%86/"}],"tags":[{"name":"踩过的坑","slug":"踩过的坑","permalink":"https://iamtaoxin.com/tags/%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/"}]},{"title":"判断一个对象是否为数组","date":"2018-05-17T09:57:07.000Z","path":"2018/05/17/arr-yes-or-no/","text":"如何判断一个对象是不是 Array 1. `Array.isArrya(obj)` 调用数组的 `isArray` 方法 ; 2. `obj instanceOf Array` 判断对象是否是 `Array` 的示例 ; 3. `Object.prototype.toString.call(obj) ===‘[object Array]’`Object.prototype.toString 方法会取得对象的一个内部属性 ［［Class］］ ，然后依据这个属性，返回一个类似于［object Array］的字符串作为结果，call 用来改变 toString 的 this 指向为待检测的对象 4. 判断对象是否有push等数组的一些方法。（这个方法有兼容问题，但也是一个简单易用的方法） 5. `obj.constructor===Array //true` 同理判断一个对象是否是函数： console.log(Object.prototype.toString.call(obj)===&#39;[object Function]&#39;) //true或false","categories":[{"name":"个人笔记","slug":"个人笔记","permalink":"https://iamtaoxin.com/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://iamtaoxin.com/tags/JavaScript/"}]},{"title":"前端JS面试必须知道的几个点","date":"2018-05-17T09:54:44.000Z","path":"2018/05/17/fe-interview/","text":"I.函数的三种定义方法1.1 函数声明// ES5 function getSum() function ()&#123;&#125; //匿名函数 // ES6 () => &#123;&#125; //如果 &#123;&#125; 内容只有一行 &#123;&#125; 和return 关键字可省略 1.2 函数表达式（函数字面量）// ES5 var sum = function getSum() // ES6 let sum = () => &#123;&#125; //如果&#123;&#125; 内容只有一行 &#123;&#125; 和return 关键字可省略 1.3 构造函数var sum = new GetSum(num1, num2); 1.4 三种方法的比较 函数声明有预解析，而且函数声明的优先级高于变量； 使用 Function 构造函数定义函数的人方式是一个函数表达式，这种方式会导致解析两次代码，影响性能。第一次解析常规的 Javascript 代码，第二次解析传入构造函数的字符串。 II. ES5 中函数的 4 种调用2.1 函数调用模式该模式包括 函数名() 和匿名函数调用， this 指向 window function getSum() &#123; console.log(this); //window &#125; getSum()(function () &#123; console.log(this); //window &#125;)(); var getSum = function () &#123; console.log(this); //window &#125;; getSum(); 2.2 方法调用对象.方法名(), this 指向 对象 var objList = &#123; name: \"methods\", getSum: function () &#123; console.log(this); //objList对象 &#125;, &#125;; objList.getSum(); 2.3 构造器调用new 构造函数名 (), this 指向构造函数 function Person() &#123; console.log(this); //指向构造函数Person &#125; var personOne = new Person(); 2.4 间接调用利用 call 和 apply 来实现，this 就是 call 和 apply 对应的第一个参数，如果不传值或者第一个值为 null , undefined 时 指向 window function foo() &#123; console.log(this); &#125; foo.apply(\"我是apply改变的this值\"); foo.call(\"我是call改变的this值\"); III. ES6 中函数的调用箭头函数不可以当作构造函数，也就是不能用 new 命令实例化一个对象，否则会抛出一个错误箭头函数的 this 是和定义时有关，和调用无关调用就是函数调用模式 () => &#123; console.log(this); //window &#125;; let arrowFun = () => &#123; console.log(this); //window &#125;; arrowFun(); let arrowObj = &#123; arrFun: function () &#123; (() => &#123; console.log(this); //arrowObj &#125;)(); &#125;, &#125;; arrowObj.arrFun; IV. call, apply 和 bind IE5 之前不支持 call 和 apply，bind 是 ES5 之后出来的； call 和 apply 可以调用函数，改变 this,实现继承和借用别的对象的方法。 4.1 call 和 apply 定义调用方法，用一个对象替换掉另一个对象 (this)对象.call(新 this 对象，实参 1，实参 2，实参 3…)对象.apply(新 this 对象，[实参 1，实参 2，实参 3…]) 4.2 call 和apply 用法 a. 间接调用函数，改变作用域的 this 值； b. 劫持其他对象的方法 var foo = &#123; name: \"张三\", logName: function () &#123; console.log(this.name); &#125;, &#125;; var bar = &#123; name: \"李四\", &#125;; foo.logName.call(bar); //李四 // 实质是call改变了foo的this指向为bar，并调用函数 c. 两个函数实现继承 &lt;div style=\"font-size:20px\" > function Animal(name)&#123; this.name = name; this.showName = function ()&#123; console.log(this.name); &#125; &#125; function Cat(name)&#123; Animal.call(this, name); &#125; var cat = new Cat('Black Cat'); cat.showName(); // Black Cat &lt;/div> d. 为类数组(arguments 和nodeList)添加数组方法 push，pop (function () &#123; Array.prototype.push.call(arguments, \"王五\"); console.log(arguments); //['张三','李四','王五'] &#125;)(\"张三\", \"李四\"); e. 合并数组 let arr1 = [1, 2, 3]; let arr2 = [4, 5, 6]; Array.prototype.push.apply(arr1, arr2); //将arr2合并到了arr1中 f. 求数组最大值 Math.max.apply(null, arr); g. 判断字符类型 Object.prototype.toString.call(&#123;&#125;); // [object Object] V. JS 常见的四种设计模式5.1 工厂模式简单的工厂模式可以理解为解决多个相似的问题； function CreatePerson(name, age, sex) &#123; var obj = new Object(); obj.name = name; obj.age = age; obj.sex = sex; obj.sayName = function () &#123; return this.name; &#125;; return obj; &#125; var p1 = new CreatePerson(\"Tom\", \"28\", \"男\"); var p2 = new CreatePerson(\"Lisa\", \"21\", \"女\"); console.log(p1.name); // longen console.log(p1.age); // 28 console.log(p1.sex); // 男 console.log(p1.sayName()); // longen console.log(p2.name); // tugenhua console.log(p2.age); // 27 console.log(p2.sex); // 女 console.log(p2.sayName()); // tugenhua 5.2 单例模式只能被实例化(构造函数给实例添加属性与方法)一次 //单体模式 var Singleton = function (name) &#123; this.name = name; &#125;; Singleton.prototype.getName = function () &#123; return this.name; &#125;; //获取实例对象 var getInstance = (function () &#123; var instance = null; return function (name) &#123; if (!instance) &#123; //相当于一个一次性阀门，只能实例化一次 instance = new Singleton(name); &#125; return instance; &#125;; &#125;)(); //测试单体模式的实例，所以 a===b var a = getInstance(\"aa\"); var a = getInstance(\"bb\"); 5.3 沙箱模式将一些函数放到自执行函数里面，但要闭包暴露接口，用变量接受暴露的接口，再调用里面的值，否则无法使用里面的值。 let sanboxModel = (function () &#123; function sayName() &#123;&#125; function sayAge() &#123;&#125; return &#123; sayName: sayName, sayAge: sayAge, &#125;; &#125;)(); 5.4 发布者订阅模式就例如我们关注了某一个公众号，然后他对应的有新的消息就会给你推送。 //发布者与订阅模式 var shoeObj = &#123;&#125;; // 定义发布者 shoeObj.list = []; //缓存列表 存放订阅者回调函数 // 增加订阅者 shoeObj.listen = function (fn) &#123; shoeObj.list.push(fn); // 订阅消息添加到缓存列表 &#125;; // 发布消息 shoeObj.trigger = function () &#123; for (var i = 0, fn; (fn = this.list[i++]); ) &#123; fn.apply(this, arguments); //第二个参数只是改变fn的this &#125; &#125;; // 小红订阅如下消息 shoeObj.listen(function (color, size) &#123; console.log(\"颜色是: \" + color); console.log(\"尺码是：\" + size); &#125;); // 小花订阅如下消息 shoeObj.listen(function (color, size) &#123; console.log(\"再次打印颜色是: \" + color); console.log(\"再次打印尺码是：\" + size); &#125;); shoeObj.trigger(\"红色\", 40); shoeObj.trigger(\"黑色\", 42); 代码实现逻辑是用数组存储订阅者，发布者毁掉函数里面通知的方式是遍历订阅者数组，并将发布者内容传入订阅者数组 VI. 原型链6.1 定义对象继承属性的一个链条 6.2 构造函数，实例与原型对象的关系 var person = function (name) &#123; this.name = name; &#125;; //person是构造函数 var o3personTwo = new person(\"personTwo\"); //personTwo是实例 原型对象都有一个默认的constructor属性指向构造函数 6.3 创建实例的方法 a. 字面量 let obj = &#123; name: \"张三\" &#125;; b. Object 构造函数创建 let Obj = new Object(); Obj.name = \"张三\"; c. 使用工厂模式创建对象 function createPerson(name) &#123; var o = new Object(); o.name = name; return o; &#125; var person1 = createPerson(\"张三\"); d. 使用构造函数创建对象 function Person(name)&#123; this.name = name; &#125; var person1 = new Person('张三')； 6.4 new 运算符 a. 创建了一个新对象； b. this指向构造函数； c. 构造函数有返回，会替换 new 出来的对象，如果没有就是 new 出来的对象 d. 手动封装一个 new 运算符 var new2 = function (func) &#123; var o = Object.create(func.protorype); //创建对象 var k = func.call(o); //改变this指向，把结果赋给k if (typeof k === \"object\") &#123; //判断k的类型是不是对象 return k; &#125; else &#123; return o; &#125; &#125;; 6.5 对象的原型链 VII. 继承的方式JS 是一门弱类型动态语言，封装和继承是他的两大特性： 7.1 原型链继承","categories":[{"name":"个人笔记","slug":"个人笔记","permalink":"https://iamtaoxin.com/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://iamtaoxin.com/tags/JavaScript/"}]},{"title":"房、树、人绘画投射分析","date":"2018-03-14T02:57:19.000Z","path":"2018/03/14/house-tree-man/","text":"房树人测验(Tree-House-Person)，又称屋树人测验，它开始于 John Buck 的“画树测验”。John Buck 于 1948 年发明此方法，受测者只需在三张白纸上分别画屋、树及人就完成测试。而动态屋、树、人分析学则由 RobertC.Burn 在 1970 年发明，受测者会在同一张纸上画屋、树及人。这三者有互动作用，例如从屋及人的位置与距离都可看出受测者与家庭的关系，所以这两种分析学多数会结合使用。 房：人们成长的场所，投射恩新的安全感。 - 画楼房：智商较高； - 房子画得像庙宇：两个极端，要不就是人才，或者就是怪异的行为表达； 强调地面：缺乏安全感； 瓦片画得很仔细：追求细节和完美； 房子侧面画楼梯：想回避和间接性接触； 画烟囱：向上的直烟暗示受测者需要出气筒；向下的烟代表受测者内心的压力； 一般人画的烟方向会向右，如果向左可能有精神分裂的倾向。 树：象征感情，投射人们对环境的体验 - 单线条的树：受测者内心忧郁，如果除了单线条的树外还画了落叶，受测者很可能在 10 天之内有自杀倾向； 嫩叶：受测者渴望或正在重新开始；树干涂黑或树根呈鹰爪状：受测者潜在的攻击意识较强； 柳树：男性受测者较女性化；女性受测者则较追求完美； 女性画松树：追求成熟，较男性化；白桦树：受测者较敏感；画上树疤：受测者曾受过心理创伤，可以根据树疤在树干上的位置判断受创的大致年纪； 画果实：投射到现实生活中，他们如果压抑或遇到挫折时会退行为儿童行为；高山上一棵树：受测者可能有性行为问题或恋母情结。 人：投射受测者的自我形象和人格完整性 - 符号化的人：受测者有掩饰性，说谎的能力较强； - 头：头画得越大，受测者的心理年龄越小。一般 12 岁以后不应该出现大头小身体的样子，否则可能智力有问题。如果画的是人的背影，这是在人际关系中过分警戒、不愿意暴露自己的表现。 耳朵：孩子不画耳朵可能有逆反心理，不愿家长口罗嗦；画大耳朵的受测者如果画的不是卡通形象，可能比较敏感； 鼻子：画纽扣鼻的人可能智力有问题；成人画出鼻梁则表示对性的关注； 画牙齿：受测者有情绪、言语攻击性； 眼睛：眼睛画得太大的人比较敏感、多疑、偏执；画眼睫毛的人对美过分关注；不画瞳孔的人在人际交往中有回避倾向； 手：一般人只画形状，画手指的人太注意细节；手代表对环境的支配，伸得越开支配力越强，但一般在 90 度以下；画中手放到后面的受测者一般有被动攻击行为，如果是儿童则可能经常掩饰自己的错误行为； 脚：代表人的活动力，分得越开活动力越强；反之则比较拘谨，不善与人交往； 头发：把头发画得竖起来的受测者攻击性较强； 衣服：画口袋、纽扣的受测者比较注意细节；如果很注重对称则有强迫症的倾向； 裸体人：受测者有品行障碍或显露癖； 画出内脏：受测者有精神分裂症的倾向。 房树人图在白纸中的位置 - 位置： - 居中：受测者自我意识较强，以自我为中心； - 偏左：受测者留恋过去； - 偏右：受测者憧憬未来； - 偏上：受测者喜欢幻想； - 偏下：受测者注重现实，对安全较为关注； - 画在角落：受测者可能有病理性疾病。 其他： 在房树人之外添加很多附加物（如太阳等），这是对环境关注的表现。在房子外面画上了篱笆，则是他们缺乏安全感的表现。还有很多人画的房、树、人都是符号化的，这表明很多现代人心理防御性强，善于掩饰自己。","categories":[{"name":"个人提升","slug":"个人提升","permalink":"https://iamtaoxin.com/categories/%E4%B8%AA%E4%BA%BA%E6%8F%90%E5%8D%87/"}],"tags":[{"name":"mark","slug":"mark","permalink":"https://iamtaoxin.com/tags/mark/"}]},{"title":"Vue常见知识点","date":"2018-03-10T03:41:58.000Z","path":"2018/03/10/vue-notes/","text":"I. 什么是 MVVM?MVVM 是 Model-View-ViewModel 的缩写。它是一种设计思想。Model 层代表数据模型，也可以在 Model 中定义数据修改和操作的业务逻辑；View 代表 UI 组件，它负责将数据模型转化成 UI 展现出来；ViewModel 是一个同步 View 和 Model 的对象。 在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过 ViewModel 进行交互，Model 和 ViewModel之间的交互是双向的，因此 View 数据的变化会同步到 Model 中，而 Model 数据的变化也会立即反应到 View 上。 ViewModel 通过双向数据绑定把 View 层 和 Mode 层连接了起来，而 View 和 Model 之间的同步工作完全是自动的，不需要手动去操作 DOM 节点，不需要灌输主句状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。 II. MVVM 和 MVC 的区别？MVC 和 MVVM 都是一种设计思想。主要区别是 MVC 中 Controller 演变成了 MVVM 中的 ViewModel。 *MVVM\\ 主要解决了 MCV 中大量的 DOM\\\\ 操作是页面渲染性能降低，加载速度变慢，从而影响了用户体验。 而且当 Model 层数据频繁发生变化时，开发者需要手动更新 View 层。 III. Vue 的优点是什么？ a. 低耦合。视图层(View) 可以独立于 Model 变化和修改，一个 ViewModel 可以绑定到不同改的 View 上，当 View 发生变化 Model 可以不变，当 Model 变化的时候 View 也可以不变。 b. 可重用性。你可以把一些视图层逻辑放在一个 ViewModel 中，让很多 View 重用这段视图逻辑。 c. 独立开发。开发人员可以专注于业务逻辑和数据的开发(ViewModel)，设计人员可以专注于页面设计，使用 Expression Blend 可以很容易设计界面并生成 xml 代码。 d. 可测试。界面素来是比较难于测试的，而现在测试可以针对 ViewModel 来写专门的测试代码。 IV. Vue2.0 生命周期是什么？Vue 的生命周期总共有 创建前/后，载入前/后，销毁前/后。 a. 创建前/后：在 beforeCreate 阶段，Vue 实例的挂载元素 el 和数据对象 data 都为 undefined ，还未初始化。在 create 阶段，vue 实例的数据对象 data 有了值，但 el 仍然没有。 b. 载入前/后：在 beforeMount 阶段，Vue 实例的 $el 和 data 都初始化了，但还是挂载之前虚拟的 DOM 节点，data.message 还未替换。在 mounted 阶段，Vue 实例挂载完成，data.message 成功渲染。 c. 更新前/后：当 data 发生变化时，会触发 beforeUpdate 和 update 方法。 d. 销毁前/后: 在执行 destroy 方法后，对 data的改变不会再触发周期函数，说明此时 Vue 实例已经解除了事件监听以及和 DOM 的绑定，但是 DOM结构依然存在。 V. Vue1.0 和 Vue2.0的对比 1.片段代码: 在 Vue2.0 中，每个组件模板中，必须有一个根元素，来包裹所有的元素。 &lt;!-- 之前: 在1.0使用时完全没问题 --> &lt;template&gt; &lt;h3&gt;我是组件&lt;/h3&gt; &lt;strong&gt;我是加粗标签&lt;/strong&gt;&lt;/template&gt;&lt;!– 现在: 必须有根元素，包裹住所有的代码 –&gt;&lt;template id=“aaa“&gt; &lt;div&gt; &lt;h3&gt;我是组件&lt;/h3&gt; &lt;strong&gt;我是加粗标签&lt;/strong&gt; &lt;/div&gt;&lt;/template&gt;:hexoPostRenderEscape–&gt; 2.生命周期见下表 vue1.0 vue2.0 描述 init beforeCreate 组件实例刚被创建，组件属性计算之前，如 data 属性等。 created created 组件实例创建完成，属性已绑定，但 DOM 还未生成，$el属性还不存在。 beforeCompile boforeMount 模板编译/挂载之前 compiled mounted 模板编辑/挂载之后 ready mounted 模板编译/挂载之后（不保证组件已在 document 中） - beforeUpdate 组件更新之前 - updated 组件更新之后 - activated for keep-alive ，组件被激活时调用 - deactivated for keep-alive ，组件被移除时调用 attached - - deattached - - beforeDestroy beforeDestroy 组件销毁前调用 destroyed destroyed 组件销毁后调用 3.过滤器2.0 删除了 1.0 所有自带的过滤器，将不再是传参的方式调用，如下： &#123;&#123;msg | mimi '12' '5'&#125;&#125; 而现在2.0中，要使用过滤器，必须要自定义一个过滤器:Vue.filter(\"toDou\", function (n, a, b) &#123; return n &lt; 10 ? n + a + b : \"\" + n; &#125;); //调用过滤器 &#123; &#123; msg | mimi(\"12\", \"5\"); &#125; &#125; 4.v-for循环 在 1.0 中循环渲染时会使用到 tranck-by=&quot;$indec&quot;来提高 for 循环的性能，而在 2.0，使用重复数据将不会报错，同时也去掉了一些隐式变量如：index 、 key，如果要用到 index 和 key 则可通过 ES6 的语法来获取： v-for=\"(val,index) in rows\" * 关于整数循环，1.0的整数循环是从0开始的，2.0的整数循环则是从1开始的。","categories":[{"name":"个人笔记","slug":"个人笔记","permalink":"https://iamtaoxin.com/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://iamtaoxin.com/tags/Vue-js/"}]},{"title":"前端面试知识点","date":"2018-02-09T06:57:44.000Z","path":"2018/02/09/front-end-md/","text":"1. CSS 盒模型 css 属性：分为 W3C 标准盒模型和 IE 标准盒模型。大多数浏览器采用 W3C 标准模型，而 IE 中采用微软自己的标准。 怪异盒模型：是指 部分浏览器在采用 W3C 标准的同时还保留了原来的解析模式，这种情况主要表现在 IE 内核的浏览器中。 怪异模式的触发：当不对 Doctype 进行定义时，则会触发怪异模式。 标准模式下：一个块的总宽度 = width + margin(左右) + padding(左右) + border(左右) 。 怪异模式下：一个块的总宽度 = width + margin(左右) ，因为 width 已经包含了 padding 和 border 值。 2. box-sizing 应用场景 语法：box-sizing:content-box || border-box || inherit; 使用场景： 1.特殊场景的布局：假设一个场景，设置子类元素的 margin 或者 border 时，可能会撑破父层元素的尺寸，这时我就需要使用 box-sizing: border-box 来讲 border 包含进元素的尺寸中，这样就不会存在撑破父层元素的情况了。 2.统一风格的表格元素：表单中有些 input 展现的还是传统的 IE 盒模型，带有一些默认的样式，而且在不同平台或者浏览器下的表现不一，造成了表单层展现的差异，此时就可以通过 box-sizing 属性来构建一个风格统一的表单元素。 3.Flex 布局。 09 年 W3C 提出了 Flex 布局，可以简便、完整、响应地实现各种页面布局。 Flex 是 Flexible Box 的缩写，意味“弹性布局”，用来为盒装模型提供最大的灵活性。 网页布局的传统解决方案，基于盒状模型，依赖 display 属性 + position 属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。 用法 # 任何一个容器都可以使用Flex布局 .box &#123; display: flex; &#125; # 行内元素也可以使用Flex布局 .box &#123; display: inline-flex; &#125; # Webkit 内核的浏览器，必须加上 -webkit 前缀 .box &#123; display: -webkit-flex; /* Safari */ display: flex; &#125; 注意，设为 Flex 布局以后，子元素的 float 、clear 和vertical-align 属性将失效。 采用 Flex 布局的元素，都成为 Flex 容器，所有子元素自动成为容器成员，成为 Flex 项目。 水平的主轴（main axis）和垂直的交叉轴（cross axis）。 主轴的开始位置（与边框的交叉点）叫做 main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。 属性： flex-direction: 决定主轴的方向，即排列方向。 .box &#123; flex-direction: * row →| row-reverse ←| column ↓| column-reverse ↑; &#125; flex-wrap: 决定一条轴线上项目的换行。 .box &#123; flex-wrap: * nowrap 不换行| wrap 换行第一行在上方| wrap-reverse 换行第一行在下方; &#125; flex-flow: flex-direction 和 flex-wrap 的简写。 默认值为 row nowrap。 .box &#123; flex-flow: &lt;flex-direction> || &lt;flex-wrap>; &#125; justify-content: 定义项目在主轴上的对齐方式。 .box &#123; justify-content: * flex-start 左对齐| flex-end 右对齐| center 居中| space-between 两端对齐| space-around 每个项目两侧的间隔相等; &#125; align-items: 定义项目在交叉轴上的对齐方式。 .box &#123; align-items: flex-start 起点对齐| flex-end 终点对齐| center 中点对齐| baseline 基线对齐| stretch 占满整个容器的高度; &#125; aligin-content: 定义多根轴线的对齐方式。 box &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch; &#125; 项目属性 order: 定义项目的排列属性。数值越小，排列越靠前，默认为 0. .item &#123; order: &lt;integer>; &#125; flex-grow: 定义项目的放大比例，默认为 0，表如果存在剩余空间，也不能放大。 item &#123; flex-grow: &lt;number>; /* default 0 */ &#125; flex-shrink: 定义项目的缩小比例，默认为 1，表如果空间不足，该项目将缩小。 .item &#123; flex-shrink: &lt;number>; /* default 1 */ 0则不缩小 &#125; flex-basis: 定义在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性进行计算主轴是否有多余空间。 .item &#123; flex-basis: &lt;length> | auto; /* default auto */ &#125; flex: 是 flex-grow , flex-shrink 和 flex-basis 的简写， 默认值为 0 1 auto。 .item &#123; flex: none | [ &lt; \"flex-grow\" > &lt; \"flex-shrink\" >? || &lt; \"flex-basis\" > ]; &#125; 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 align-self: 允许单个项目有与其他项目不一样的对齐方式，可覆盖 align-items 属性。默认值为auto，表示继承父元素的align-items 属性，如果没有父元素，则等同于stretch。 .item &#123; align-self: auto | flex-start | flex-end | center | baseline | stretch; &#125; 4.未知元素上下左右垂直居中 flex 实现方式： .div &#123; justify-content: center; align-items: center; &#125; 5.js 对象、原型链、构造函数 __proto__:每个 JS 对象一定对应一个原型对象，并继承原型对象的属性和方法。 prototye: 只有函数才有 prototype属性。JS 通过函数来模拟类，当创建函数时，JS 会为这个函数自动添加prototype属性，值是空对象。而一旦把这个函数当做构造函数（constructor）调用（即通过new调用）,JS 就会帮你创建该构造函数的实例，实例继承构造函数prototype的所有属性和方法（实例通过设置自己的 __proto__ 指向承构造函数的 prototype 来实现这种继承）。 JS 通过__proto__ 和prototype的合作实现了原型链，以及对象的继承。 构造函数，通过 protytype来存储要共享的属性和方法，也可以设置prototype指向现存的对象来继承该对象。 var one = &#123; x: 1 &#125;; var two = new Object(); one.__proto__ === Object.prototype; // true two.__proto__ === Object.prototype; // true one.toString === one.__proto__.toString; // true 对象的 __proto__ 指向自己的构造函数的 prototype 。one.__proto__.__proto__... 的原型链有次产生，包括操作符 instanceof 正是通过探测 obj.__proto__.__proto__... === Constructor.prototype 来验证 obj 是否是 Constructor 的实例。回到开头的代码，two = new Object()中 Object 是构造函数，所以 two.__proto__ 就是 Object.prototype 。至于 one ，ES 规范定义对象字面量的原型就是 Object.prototype 。 Function.prototype 和 Function.__proto__ 都指向 Function.prototype 。 Object.prototype.__proto__ == null ,说明原型链到 Object.prototye 终止。 结论： 所有对象均从 Object.prototye 继承属性。 Function.prototype 和 Function.prototype 为同一个对象。 Function.prototype 直接继承 root(Object.prototype) 。 一句话总结：先有Object.prototype(原型链顶端),Function.prototype继承Object.prototype而产生，Function和Object和其他构造函数继承Function.prototype而产生。 6.常见的布局解决方案 1.居中布局 水平居中 垂直居中 2.单列布局： 定宽，水平居中 3.二列布局&amp;三列布局 float + margin 左右浮动，中间 margin position + margin 左右绝对定位，中间 margin 圣杯布局 (float + 负margin + padding + position) 双飞翼布局 (float + 负margin + margin) Flex 布局 7.关于 WebSocket WebSocket 是 HTML5 提出的一个协议规范。 WebSocket 约定了一个通信的规范，通过一个握手的机制，客户端（浏览器）和服务器（webserver）之间能简历一个类型 TCP 的链接，从而方便 c-s 之间的通信。在 websocket 出现之前，web 交互一般是基于 http 协议的短连接或者长连接。 WebSocket 是为解决客户端与服务端实时通信而产生的技术。websocket 协议本质上是一个基于 TCP 的协议，是先通过 HTTP/HTTPS 协议发起一条特殊的 http 请求进行握手后创建一个用于交换的 TCP 连接，此后服务端与客户端通过此 TCP 连接进行实时通信。 优点： 服务器和客户端可以在给定的时间范围内的任意时刻，相互推送信息。浏览器和服务器只需要做一个握手的动作，在建立连接之后，服务器可以主动传送数据给客户端，客户端也可以随时向服务器发送数据。此外，服务器与客户端之间叫唤的标头信息很小。 以前 web server 实现推送技术或者即时通讯，用的都是轮询（polling），在特定的时间间隔由浏览器自动发出请求，将服务器的消息主动拉取，在这种情况下，浏览器需要不断地向服务器发送请求，然而 HTTP request 的 header 是非常长的，里面包含的数据可能只是一个很小的值，这样就会占用很多的带宽和服务器资源。","categories":[{"name":"个人笔记","slug":"个人笔记","permalink":"https://iamtaoxin.com/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"html","slug":"html","permalink":"https://iamtaoxin.com/tags/html/"}]},{"title":"ES6之Set个人解读","date":"2018-02-07T09:05:11.000Z","path":"2018/02/07/es6-set/","text":"参考链接：ECMAScript 6 入门- Set 和 Map 数据结构 I. 定义：Set 本身是一个构造函数，用来生成 Set 数据结构。 Set 是 ES6 中提供的新的数据结构，结构类似于数组，但 Set 中的成员的值都是唯一的，没有重复值。 Set 函数可以将一个数组作为参数，将其初始化。 const arr = [1, 2, 3, 4, 4]; const set = new Set(arr); // [1, 2, 3, 4, 4]; II. Set 实例的属性 Set 实例有以下两个属性： Set.prototype.constructor：构造函数，默认就是 Set 函数。 Set.prototype.size：返回 Set 实例的成员总数。 III. Set 实例的方法 Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。四个操作方法如下： add(value): 添加某个值，返回 Set 结构本身。 delete(value): 删除某个值，返回一个布尔值，表示删除是否成功。 has(value): 返回一个布尔值，表示该值是否为 Set 的成员。 clear(value): 清楚所有成员，没有返回值。 初级用法： s.add(1).add(2).add(2); // 注意2被加入了两次 s.size; // 2 s.has(1); // true s.has(2); // true s.has(3); // false s.delete(2); // true s.has(2); // false Array.from 方法可以将 Set 结构转为数组。 const items = new Set([1, 2, 3, 4, 5]); const array = Array.from(items); 这就提供了数组去重的一种方式： function dedupe(array) &#123; return Array.from(new Set(array)); &#125; dedupe([1, 1, 2, 3]); // [1, 2, 3] 中级用法 遍历操作 Set 实例的四个遍历方法： keys(): 返回键名的遍历器 values(): 返回键值的遍历器 entries(): 返回键值对的遍历器 forEach(): 使用回调函数遍历每个成员 需要特别指出的是，Set 的遍历顺序就是插入顺序。这个特性有时非常有用，比如在使用 Set 保存一个回调函数列表，调用时就能保证按照添加顺序调用。 (1) keys(), values(), entries() `keys`方法、`values`方法、`entries`方法返回的都是遍历器对象。由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以keys方法和values方法的行为完全一致。 let set = new Set([\"red\", \"green\", \"blue\"]); for (let item of set.keys()) &#123; console.log(item); &#125; // red // green // blue for (let item of set.values()) &#123; console.log(item); &#125; // red // green // blue for (let item of set.entries()) &#123; console.log(item); &#125; // [\"red\", \"red\"] // [\"green\", \"green\"] // [\"blue\", \"blue\"] 上面代码中，`entries` 方法返回的遍历器，同事包括键名和键值，所以每次输出一个数组，它的两个成员完全相等。Set 结构的实例默认可遍历，它的默认遍历器生成函数就是它的 values() 方法。 Set.prototype[Symbol.iterator] === Set.prototype.values; // true 这意味着，可以省略 `values` 方法，直接用 `for…of`遍历循环 Set。let set = new Set([\"red\", \"green\", \"blue\"]); for (let x of set) &#123; console.log(x); &#125; // red // green // blue (2) forEach() `forEach` 方法用于对每个成员执行某种操作，没有返回值。 set = new Set([1, 2, 4]); set.forEach((value, key) => console.log(key + \":\" + value)); // 1:1 // 2:2 // 4:4 上面代码说明， `forEach` 方法的参数就是一个处理函数，该函数的参数与数组的 `forEach` 一致，依次为 键值、键名、集合本身 。Set 的键名和键值永远是一样的。 另外，`forEach`方法还可以有第二个参数，表示绑定处理函数内部的 `this` 对象。 (3)遍历的应用 扩展运算符(`...`) 内部使用 `for…of` 循环，所以也可以用于 Set 结构。 let set = new Set([\"red\", \"green\", \"blue\"]); let arr = [...set]; // ['red', 'green', 'blue'] 扩展运算符和 Set 结构相符合，就可以进行数组去重了。let arr = [3, 5, 2, 2, 5, 5]; let unique = [...new Set(arr)]; // [3, 5, 2] 进阶方法 数组的 map 和 filter 方法也可适用于 Set。 let set = new Set([1, 2, 3]); set = new Set([...set].map((x) => x * 2)); // 返回的set结构： &#123;2, 4, 6&#125;; let set = new Set([1, 2, 3, 4, 5]); set = new Set([...set].filter((x) => x % 2 == 0)); // 返回Set结构：&#123;2, 4&#125; 用 Set 实现并集（Union）、交集（Intersect）和差集（Difference）。 let a = new Set([1, 2, 3]); let b = new Set([4, 3, 2]); // 并集 let union = new Set([...a, ...b]); // Set &#123;1, 2, 3, 4&#125; // 交集 let intersect = new Set([...a].filter((x) => b.has(x))); // set &#123;2, 3&#125; // 差集 let difference = new Set([...a].filter((x) => !b.has(x))); // Set &#123;1&#125; 如果想在遍历操作中，同步改变原来的 Set 结构，目前没有直接的方法，但有两种变通方法。一种是利用原 Set 结构映射出一个新的结构，然后赋值给原来的 Set 结构；另一种是利用 Array.from 方法。 // 方法一 let set = new Set([1, 2, 3]); set = new Set([...set].map((val) => val * 2)); // set的值是2, 4, 6 // 方法二 let set = new Set([1, 2, 3]); set = new Set(Array.from(set, (val) => val * 2)); // set的值是2, 4, 6","categories":[{"name":"个人笔记","slug":"个人笔记","permalink":"https://iamtaoxin.com/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://iamtaoxin.com/tags/JavaScript/"}]},{"title":"App Shell模型","date":"2018-02-06T08:29:09.000Z","path":"2018/02/06/app-shell-md/","text":"文章来自：App Shell 模型 | Web | Google Developers App Shell 架构是构建 Progressive Web App 的一种方式，这种应用能可靠且即时地加载到您的用户屏幕上，与本机应用相似。 App Shell 是支持用户界面所需的最小的 HTML、CSS 和 JavaScript，如果离线缓存，可确保在用户重复访问时提供 即时、可靠的良好性能。这意味着并不是每次用户访问时都要从网络加载 App Shell，只需要从网络中加载必要的内容。 对于使用包含大量 JavaScript 的架构的 单页应用来说，App Shell 是一种常用方法。这种方法依赖渐进式缓存 Shell（使用服务工作线程：简介 | Web | Google Developers）让应用运行。接下来，为使用 JavaScript 的每个页面加载动态内容。App Shell 非常适合用于在没有网络的情况下将一些初始 HTML 快速加载到屏幕上。 换个说法，App Shell 就类似于您在开发本机应用时需要向应用商店发布的一组代码。 它是 UI 的主干以及让您的应用成功起步所需的核心组件，但可能并不包含数据。 注：请尝试Your First Progressive Web App代码实验室，了解如何为天气应用构建和实现第一个 App Shell。使用 Shell Model 应用即时下载（第三季，第二集） - YouTube也演练了这种模式。 何时使用 App Shell 模型构建 PWA 并不意味着从头开始。如果您构建的是现代单页应用，那么您很可能使用的就是类似于 App Shell 的模型，不管您是否这么称呼它。根据您使用的内容库或框架的不同，详细内容可能略有不同，但该概念本身与框架无关。 App Shell 架构具有相对不变的导航以及一直变化的内容，对应于和网站意义重大。 大量现代 JavaScript 框架和内容库已经鼓励拆分应用逻辑及其内容，从而使这种架构更能直接应用。对于只有静态内容的某一类网站，您也可以使用相同的模型，但网站 100% 是 App Shell。 如需了解 Google 构建 App Shell 架构的方式，请查看构建Building the Google I/O 2016 Progressive Web App | Web | Google Developers。这个真实的应用以 SPA 开始创建 PWA，使用服务工作线程预先缓存内容、动态加载新页面、在视图之间完美过渡，并且在第一次加载后重用内容。 优势使用服务工作线程的 App Shell 架构的优势包括： 始终快速的可靠性能。重复访问速度极快。 第一次访问时即可缓存静态资产和 UI（例如 HTML、JavaScript、图像和 CSS），以便在重复访问时即时加载。内容可能会在第一次访问时缓存到系统中，但一般会在需要时才进行加载。 如同本机一样的交互。通过采用 App Shell 模型，您可以构建如同本机应用一样的即时导航和交互，包括离线支持。 数据的经济使用。其设计旨在实现最少的数据使用量，并且可以正确判断缓存的内容，因为列出不需要的文件（例如，并不是每个页面都显示的大型图像）会导致浏览器下载的数据超出所必需的量。尽管在西方国家和地区中，数据相对较廉价，但新兴市场并非如此，这些市场中连接和数据费用都非常昂贵。 要求 App Shell 应能完美地执行以下操作： 快速加载 尽可能使用较少的数据 使用本机缓存中的静态资产 将内容与导航分离开来 检索和显示特定页面的内容（HTML、JSON 等） 可选：缓存动态内容App Shell 可保证 UI 的本地化以及从 API 动态加载内容，但同时不影响网络的可链接性和可检测性。 用户下次访问您的应用时，应用会自动显示最新版本。无需在使用前下载新版本。 注：Lighthouse审核扩展可用于验证使用 App Shell 的 PWA 是否获得了高性能。 To the Lighthouse (Progressive Web App Summit 2016) - YouTube介绍了使用这个工具优化 PWA 的过程。 构建您自己的 App Shell 构建您自己的应用，明确区分页面 Shell 和动态内容。 一般而言，您的应用应加载尽可能最简单的 Shell，但初始下载时应包含足够的有意义的页面内容。 确定每个数据来源的速度与数据新鲜度之间的正确平衡点。 Jake Archibald 的离线维基百科应用Rick and Morty - Offline Wikipedia就是使用 App Shell 模型的 PWA 好例子。它会在重复访问时即时加载，但同时使用 JS 动态抓取内容。系统随后会离线缓存此内容，以备以后访问。 App Shell 的 HTML 示例 此示例将核心应用基础架构和 UI 从数据中分离出来。请务必使初始加载尽可能简单，在打开网络应用后仅显示页面的布局。有些数据来自于应用的索引文件（内联 DOM、样式），其他数据加载自外部脚本和样式表。 所有 UI 和基础架构都使用服务工作线程本地缓存，因此，随后的加载将仅检索新数据或发生更改的数据，而不是必须加载所有数据。 您工作目录中的 index.html 文件内容应类似于以下代码。 这是实际内容的子集，不是完整的索引文件。 让我们看看它包含的内容。 用户界面“主干”的 HTML 和 CSS，包含导航和内容占位符。 用于处理导航和 UI 逻辑的外部 JavaScript 文件 (app.js)，以及用于显示从服务器中检索的帖子并使用 IndexedDB 等存储机制将其存储在本地的代码。 网络应用清单和用于启用离线功能的服务工作线程加载程序。 &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset=\"utf-8\" /> &lt;title>App Shell&lt;/title> &lt;link rel=\"manifest\" href=\"/manifest.json\" /> &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" /> &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /> &lt;title>App Shell&lt;/title> &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"styles/inline.css\" /> &lt;/head> &lt;body> &lt;header class=\"header\"> &lt;h1 class=\"header__title\">App Shell&lt;/h1> &lt;/header> &lt;nav class=\"nav\"> ... &lt;/nav> &lt;main class=\"main\"> ... &lt;/main> &lt;div class=\"dialog-container\"> ... &lt;/div> &lt;div class=\"loader\"> &lt;!-- Show a spinner or placeholders for content --> &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;div&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;script&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation attr-equals&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;app.js&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;async&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token script&quot;&gt;&lt;/span&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;script&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;script&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token script&quot;&gt;&lt;span class=&quot;token language-javascript&quot;&gt; &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;serviceWorker&quot;&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;in&lt;/span&gt; navigator&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;&amp;#123;&lt;/span&gt; navigator&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;serviceWorker &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;register&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;/sw.js&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;registration&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;&amp;#123;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// Registration was successful&lt;/span&gt; console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;ServiceWorker registration successful with scope: &quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; registration&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;scope &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;&amp;#125;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;catch&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;&amp;#123;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// registration failed :(&lt;/span&gt; console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;ServiceWorker registration failed: &quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; err&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;&amp;#125;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;&amp;#125;&lt;/span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;script&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt; &lt;/body&gt;&lt;/html&gt;:hexoPostRenderEscape–&gt; 注：请参阅 https://app-shell.appspot.com/，查看一个非常简单的、使用 App Shell 和内容服务器端渲染的 PWA 的真实演示。App Shell 可通过使用任意内容库或框架实现（如我们的所有框架上的 Progressive Web App 讲座中Progressive Web Apps across all frameworks - Google I/O 2016 - YouTube所述）。您可以使用 Polymer (SHOP) 和 React （ReactHN 、iFixit）查看示例。 缓存 App Shell 您可以使用手动编写的服务工作线程或通过 sw-precache 等静态资产预缓存工具生成的服务工作线程缓存 App Shell。 注：这些示例仅为呈现一般信息以及进行说明而提供。 您的应用使用的实际资源很可能不同。 手动缓存 App Shell以下是使用服务工作线程的 install 事件将 App Shell 中的静态资源缓存到 Cache API Cache - Web APIs | MDN 中的服务工作线程代码示例: ar cacheName = 'shell-content'; var filesToCache = [ '/css/styles.css', '/js/scripts.js', '/images/logo.svg', '/offline.html’, '/’ ]; self.addEventListener('install', function(e) &#123; console.log('[ServiceWorker] Install'); e.waitUntil( caches.open(cacheName).then(function(cache) &#123; console.log('[ServiceWorker] Caching app shell'); return cache.addAll(filesToCache); &#125;) ); &#125;); 使用 sw-precache 缓存 App Shell sw-precache 生成的服务工作线程会缓存并提供您在构建过程中配置的资源。 您可以让此线程预先缓存构成 App Shell 的每个 HTML、JavaScript 和 CSS 文件。 所有资源都可以离线工作，并且可在随后的访问中快速加载相关内容，无需其他操作。 以下是在 gulp 构建过程中使用 sw-precache 的基本示例： gulp.task(\"generate-service-worker\", function(callback) &#123; var path = require(\"path\"); var swPrecache = require(\"sw-precache\"); var rootDir = \"app\"; swPrecache.write( path.join(rootDir, \"service-worker.js\"), &#123; staticFileGlobs: [rootDir + \"/**/*.&#123;js,html,css,png,jpg,gif&#125;\"], stripPrefix: rootDir &#125;, callback ); &#125;); 如需了解有关静态资产缓存的详细信息，请参阅使用 sw-precache 添加服务工作线程代码实验室Adding a Service Worker with sw-precache。 注：sw-precache 对于离线缓存您的静态资源非常有用。对于运行时/动态资源，我们建议使用我们的免费内容库sw-toolbox。 结论 使用服务工作线程的 App Shell 是实现离线缓存的强大模式，但同时还可以针对 PWA 的重复访问实现即时加载这一重要性能。您可以缓存自己的 App Shell ，以便它可以离线使用并使用 JavaScript 填充其内容。 如果重复访问，这样还可让您在没有网络的情况下（即使您的内容最终源自网络）在屏幕上获得有意义的像素。","categories":[{"name":"技术整理","slug":"技术整理","permalink":"https://iamtaoxin.com/categories/%E6%8A%80%E6%9C%AF%E6%95%B4%E7%90%86/"}],"tags":[{"name":"PWA","slug":"PWA","permalink":"https://iamtaoxin.com/tags/PWA/"}]},{"title":"vue.js组件使用和开发规范","date":"2017-07-13T01:28:38.000Z","path":"2017/07/13/vue-use-dev-normal/","text":"参考：Vue.js风格指南 开发规范开发之前尽量使用最新ES语法，具体如下： 正确使用const和let替代var 使用模板字符串$&#123;this.data&#125; 将工具函数等依赖单独分离，并用import导入 对象字面量缩写、箭头函数 通用工具集可以在utils/assist内扩展 在local/routers内测试组件 组件1,命名 尽量简单、表意 export 出的对象是用驼峰命名法，比如 Page 、 ButtonItem 如组件需要嵌套使用，子组件命名在父组件后加-item，比如timeline及timeline-item 2,目录 组件应在目录 compoents/下，每个组件要有单独的目录，目录命名是用小写，入口文件为index.js，导出组件，再由index.js 暴露给使用者 每个组件的文件名当使用小写， 但必须与组件的名称一致，比如 timeline.vue和timeline-item.vue 3,属性 必须规定type或者使用validator进行验证 如果validator验证为几个值中的一个，则使用utils/assist内的oneOf函数进行验证 如果有尺寸的参数size，则只能使用small 、large，默认是适中，可不写 事件1,命名 使用on- 为前缀，比如on-change 2,规范 使用$emit来对外触发事件，而不用$dispatch和$broadcast 嵌套组件之间通信，使用$parent和$children，而不用$emit，避免使用这错误使用自定义事件 其他 css前缀 使用规范使用 :prop 传递数据类型为数字 或 boolean时，必须带 :,比如： 正确的使用方法： &lt;Page :current=1 :total=\"100\">&lt;/Page> 错误的使用方法： &lt;Page current=\"1\" total=\"100\">&lt;/Page>","categories":[{"name":"技术整理","slug":"技术整理","permalink":"https://iamtaoxin.com/categories/%E6%8A%80%E6%9C%AF%E6%95%B4%E7%90%86/"}],"tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://iamtaoxin.com/tags/Vue-js/"}]},{"title":"搭建Http静态服务器环境","date":"2017-07-02T03:23:08.000Z","path":"2017/07/02/nginx/","text":"搭建静态网站，首先需要部署环境。下面的步骤，将告诉大家如何在服务器上通过 Nginx 部署 HTTP 静态服务 安装Nginx 在 CentOS 上，可直接使用 yum 来安装 Nginx yum install nginx -y 安装完成后，使用 nginx 命令启动 Nginx: nginx 此时，访问 http://&lt;您的域名&gt; 可以看到 Nginx 的测试页面*如果无法访问，请重试用 nginx -s reload 命令重启 Nginx* 配置静态服务器访问路径 外网用户访问服务器的 Web 服务由 Nginx 提供，Nginx 需要配置静态资源的路径信息才能通过 url 正确访问到服务器上的静态资源。 打开 Nginx 的默认配置文件 /etc/nginx/nginx.conf ，修改 Nginx 配置，将默认的root /usr/share/nginx/html; 修改为: root /data/www;，如下：示例代码：/etc/nginx/nginx.conf user nginx; worker_processes auto; error_log /var/log/nginx/error.log; pid /run/nginx.pid; include /usr/share/nginx/modules/ *.conf; events &#123; worker_connections 1024; &#125; http &#123; log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_forwarded_for\"'; access_log /var/log/nginx/access.log main; sendfile on; tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; types_hash_max_size 2048; include /etc/nginx/mime.types; default_type application/octet-stream; include /etc/nginx/conf.d/ *.conf; server &#123; listen 80 default_server; listen [::]:80 default_server; server_name _; root /data/www; include /etc/nginx/default.d/ *.conf; location / &#123; &#125; error_page 404 /404.html; location = /40x.html &#123; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; &#125; &#125; &#125; 配置文件将 /data/www/static 作为所有静态资源请求的根路径，如访问: http://&lt;您的域名&gt;/static/index.js，将会去 /data/www/static/目录下去查找 index.js。现在我们需要重启 Nginx 让新的配置生效，如 nginx -s reload 重启后，现在我们应该已经可以使用我们的静态服务器了，现在让我们新建一个静态文件，查看服务是否运行正常。 首先让我们在 /data 目录 下创建 www 目录，如： mkdir -p /data/www 创建第一个静态文件 在 /data/www 目录下创建我们的第一个静态文件index.html 示例代码：/data/www/index.html &lt;!DOCTYPE html> &lt;html lang=\"zh\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>第一个静态文件&lt;/title> &lt;/head> &lt;body> Hello world！ &lt;/body> &lt;/html> 现在访问 http://&lt;您的域名&gt;/index.html 应该可以看到页面输出 [Hello world!] 到此，一个基于 Nginx 的静态服务器就搭建完成了，现在所有放在 /data/www 目录下的的静态资源都可以直接通过域名访问。 注：如果无显示，请刷新浏览器页面。","categories":[{"name":"技术整理","slug":"技术整理","permalink":"https://iamtaoxin.com/categories/%E6%8A%80%E6%9C%AF%E6%95%B4%E7%90%86/"}],"tags":[{"name":"bash","slug":"bash","permalink":"https://iamtaoxin.com/tags/bash/"}]},{"title":"关于Js页面中oss在https下web直传的问题","date":"2017-05-24T08:19:44.000Z","path":"2017/05/24/guan-yu-js-ye-mian-zhong-oss-zai-https-xia-web-zhi-chuan-de-wen-ti/","text":"在页面中进行 web端 直传，开发环境下测试没有问题，但部署到服务器上时出现了问题，服务器上的站点是基于 https 协议进行访问的，在此情况下，web端 直传出现了异常，原因是在 HTTPS 网页中，不允许发起 HTTP 的请求，可以使用 https 的 endpoint ，示例如下： var client = new OSS.Wrapper(&#123; region: 'oss-cn-shanghai', secure: true, // 为true时，即允许发起http请求 accessKeyId: '', accessKeySecret: '' &#125;);","categories":[{"name":"技术整理","slug":"技术整理","permalink":"https://iamtaoxin.com/categories/%E6%8A%80%E6%9C%AF%E6%95%B4%E7%90%86/"}],"tags":[{"name":"踩过的坑","slug":"踩过的坑","permalink":"https://iamtaoxin.com/tags/%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/"}]},{"title":"Vue使用阿里oss上传图片功能(二)","date":"2017-05-24T06:35:08.000Z","path":"2017/05/24/vue-ye-mian-shi-yong-a-li-oss-shang-chuan-tu-pian-gong-neng-er/","text":"主要介绍OSS管理控制台设置访问权限、角色等。demo源码 进入控制台，鼠标移到右上角用户名处，点击“访问控制”,如下图：如果没有此功能，则将鼠标移至 产品 -&gt; 管理与控制，点击 访问控制进入访问控制产品页 1.创建子账号 点击左侧的 用户管理 -&gt; 自定义授权策略 -&gt;新建授权策略 ， 如下图： 2.新建授权策略 点击左侧的 策略管理 -&gt; 新建用户 ， 如下图： 在弹出对话框中：选择授权策略模板（使用空模板） 编辑授权策略并提交：修改 授权策略名称（自定义名称），备注，策略内容，并提交。 示例*：一个MNS授权策略内容模版:&#123; \"Statement\": [ &#123; \"Action\": \"mns:*\", \"Effect\": \"Allow\", \"Resource\": \"acs:mns:*:*:*\" &#125; ], \"Version\": \"1\" &#125; 授权策略*是json格式的字符串，其中， Action* ： 表示要授权的操作，MNS 操作都以”mns:”开头，例如: “mns:SendMessage” 表示 MNS 服务的API：SendMessage/BatchSenMessage其他详见附录：MNS API和授权操作映射表； Effect* ： 表示授权类型， 例如:Allow, Deny Resrouce** : 表示要授权的阿里云资源名（ARN），格式为：”acs:&lt;云服务名&gt;: &lt;地域名&gt;: &lt;主账号UID&gt;:&lt;资源URI&gt;”例如：“acs:mns:cn-hangzhou:123456789:/queues/MyQueue1/messages”表示：授权资源是主账号UID为123456789在cn-hangzhou地域的MyQueue1。用”“表示不指定具体的字段，例如：”acs:mns:::*” 表示不指定地域名,主账号ID和资源URI，子账号可以访问主账号的所有mns资源。 3.授权子账号访问MNS 返回 用户管理 ,找到第一步创建的子账号，点击右侧 授权 在弹出的对话框中，选择授权策略名称，并添加到右侧已选授权策略列表，点击 确定 提交，如下图： 4.创建角色 点击左侧的 角色管理 -&gt; 新建角色如下图： 4.授权策略访问角色 点击左侧的 角色管理 ,在右侧的角色列表中选择需要授权的角色，点击授权，如下图： 5.注意事项1.server端的代码中 var sts = new STS(&#123; accessKeyId: '子账号 accessKeyId', accessKeySecret: '子账号 accessKeySecret', &#125;); accessKeyId 和 accessKeySecret 为第一步创建的子用户的 key 2. rolearn &lt;!--hexoPostRenderEscape:&lt;pre class=&quot;line-numbers language-javascript&quot; data-language=&quot;javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; rolearn &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#39;对应角色的Arn值&#39;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;:hexoPostRenderEscape--&gt; 3.policy &lt;!--hexoPostRenderEscape:&lt;pre class=&quot;line-numbers language-javascript&quot; data-language=&quot;javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; policy &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;&amp;#123;&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;Version&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;1&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;Statement&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;&amp;#123;&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;Effect&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;Allow&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;Action&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;oss:GetObject&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;oss:PutObject&quot;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;Resource&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;acs:oss:*:*:BucketName&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;acs:oss:*:*:BucketName/*&quot;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;&amp;#125;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&#125;;:hexoPostRenderEscape–&gt; 这里的policy 必须和之前创建的策略一致。","categories":[{"name":"技术整理","slug":"技术整理","permalink":"https://iamtaoxin.com/categories/%E6%8A%80%E6%9C%AF%E6%95%B4%E7%90%86/"}],"tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://iamtaoxin.com/tags/Vue-js/"}]},{"title":"Vue使用阿里oss上传图片功能(一)","date":"2017-05-24T01:11:56.000Z","path":"2017/05/24/vue-ye-mian-shi-yong-a-li-oss-shang-chuan-gong-neng-yi/","text":"demo源码 前端部分 1.前端页面中需要引入oss-sdk: &lt;script src=\"http://gosspublic.alicdn.com/aliyun-oss-sdk-4.4.4.min.js\">&lt;/script> 2.自己封装的upload组件： &lt;template> &lt;div> &lt;div class=\"oss_file\"> &lt;input type=\"file\" :id=\"id\" :multiple=\"multiple\" @change=\"doUpload\"/> &lt;/div> &lt;/div> &lt;/div> &lt;/template> &lt;script> export default&#123; props:&#123; multiple:&#123; type: Boolean, twoWay:false &#125;, id:&#123; type: String, twoWay:false &#125;, url:&#123; type: Array, twoWay:true &#125; &#125;, data()&#123; return&#123; region:'Your oss Region', bucket:'Bucket Name', &#125;; &#125;, methods:&#123; doUpload()&#123; const _this = this; Vue.http.get('/alioss/getOssToken').then((result) => &#123; const client = new OSS.Wrapper(&#123; region:_this.region, accessKeyId: result.data.token.AccessKeyId, accessKeySecret: result.data.token.AccessKeySecret, stsToken: result.data.token.SecurityToken, bucket:_this.bucket &#125;) const files = document.getElementById(_this.id); if(files.files)&#123; const fileLen = document.getElementById(_this.id).files const resultUpload = []; for (let i = 0; i &lt; fileLen.length; i++) &#123; const file = fileLen[i]; const storeAs = file.name; client.multipartUpload(storeAs, file, &#123; &#125;).then((results) => &#123; if(results.url)&#123; resultUpload.push(results.url); &#125; &#125;).catch((err) => &#123; console.log(err); &#125;); &#125; _this.url = resultUpload; &#125; &#125;); &#125; &#125; &#125;; &lt;/script> &lt;style type=\"text/css\"> .oss_file &#123; height: 100px; width: 100%; &#125; .oss_file input &#123; right: 0; top: 0; opacity: 0; filter: alpha(opacity=0); cursor: pointer; width: 100%; height: 100%; &#125; &lt;/style> 3.使用组件： &lt;template> &lt;div> &lt;div> &lt;ali-upload :url.sync=\"uploadUrl\" :multiple=\"true\" :id=\"uploadId\" :code.sync=\"uploadCode\">&lt;/ali-upload> &lt;/div> &lt;div v-for=\"url in uploadUrl\"> ![](url) &lt;/div> &lt;/div> &lt;/div> &lt;/template> &lt;script> import aliUpload from './../components/aliossupload.vue'; export default&#123; components:&#123; aliUpload &#125;, data()&#123; return&#123; uploadUrl:[], uploadId:'file', uploadCode:0 &#125;; &#125;, watch:&#123; uploadCode(val)&#123; console.info(val) &#125; &#125; &#125;; &lt;/script> 后端部分 1.首先安装依赖 npm install ali-oss npm install co 2.service文件 'use strict' var OSS = require('ali-oss'); var STS = OSS.STS; var co = require('co'); var sts = new STS(&#123; accessKeyId: 'accessKeyId', accessKeySecret: 'accessKeySecret', &#125;); var rolearn = 'acs:ram::ID:role/ram'; var policy = &#123; \"Version\": \"1\", \"Statement\": [ &#123; \"Effect\": \"Allow\", \"Action\": [ \"oss:GetObject\", \"oss:PutObject\" ], \"Resource\": [ \"acs:oss:*:*:Bucket\", \"acs:oss:*:*:BucketName/*\" ] &#125; ] &#125;; class OssUploadService &#123; getOssToken(req, res)&#123; var result = co(function* () &#123; var token = yield sts.assumeRole(rolearn, policy, 15 * 60, 'ossupload'); res.json(&#123; token:token.credentials &#125;) &#125;).catch(function (err) &#123; &#125;); &#125; &#125; module.exports = new OssUploadService() 2.controller文件 'use strict' var ossUploadService = require('../service/ossUploadService') module.exports = function(app) &#123; app.get('/alioss/getOssToken', function(req, res) &#123; const result = ossUploadService.getOssToken(req, res) if (result) &#123; res.json(&#123; code: 100, data: result &#125;) &#125; &#125;) &#125; 到这里就大功告成了吗？错！这只是完成了最基本的部分，接下来我们要在阿里云控制台中设置权限、角色、策略等。","categories":[{"name":"技术整理","slug":"技术整理","permalink":"https://iamtaoxin.com/categories/%E6%8A%80%E6%9C%AF%E6%95%B4%E7%90%86/"}],"tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://iamtaoxin.com/tags/Vue-js/"}]},{"title":"CentOS 安装 Node.js、npm、htop、pm2","date":"2017-05-21T14:23:16.000Z","path":"2017/05/21/centos-an-zhuang-node-js-npm-htop-pm2/","text":"1. 下载node.js $ wget http://nodejs.org/dist/v0.12.0/node-v0.12.0.tar.gz 2. 解压node.js $ tar xvf node-v0.12.0.tar.gz 3. 编译及安装 $ make &amp;&amp; make install 4. 查看node版本 $ node -v 1. 安装npm $ sudo yum install npm 2.查看npm版本 $ npm -v 1. 安装 htop $ sudo yum install htop 2. 安装pm2 $ npm install -g pm2","categories":[{"name":"技术整理","slug":"技术整理","permalink":"https://iamtaoxin.com/categories/%E6%8A%80%E6%9C%AF%E6%95%B4%E7%90%86/"}],"tags":[{"name":"bash","slug":"bash","permalink":"https://iamtaoxin.com/tags/bash/"}]},{"title":"Vue+leancloud轻松打造个人博客","date":"2017-05-20T13:50:44.000Z","path":"2017/05/20/vue-leancloud-qing-song-da-zao-ge-ren-bo-ke/","text":"基于 Vue.js 的纯前端博客 通过 Vue 构建博客前端框架 前端代码自动化部署到阿里云 cdn 使用阿里云和 leancloud 构建一个强大的个人博客 项目采用前端使用 vue 1.0 做为开发框架，leancloud 为本站提供数据储存服务。所有静态文件存放在阿里 OSS 上，无需另外购买服务器，这对于个人来说省了不少费用。 博客说明：该项目是个人博客 iamtaoxin 的前端源码，它属于博客系统的一部分，博客系统一共分 3 部分: 基于 Vue 1.0 构建的 Vuex 架构的博客前端页面 使用 Leancloud 作为数据存储 收藏阅读笔记的 Safari 插件 源码地址： Github 具体步骤如下：一、获取代码，安装依赖拉取博客代码至本地目录文件夹，进入文件加中 public 中安装依赖程序。 $ npm install 二、安装 leancloud SDK2.1 在index.html中添加以下代码： 具体安装指南见 ：JavaScript SDK 安装指南 2.2leancloud 初始化在ext/vue_ext.js文件中已封装好leancloud初始化的方法，如下： function AVInit() &#123; const appId = \"Your appID\"; const appKey = \"Your appkey\"; AV.init(&#123; appId: appId, appKey: appKey &#125;); &#125; 只需在 App.vue 中调用即可: ready()&#123; this.$AVInit(); &#125; 三、启动项目 $ npm run dev 四、部署项目 部署项目中使用到了aliyunoss-webpack-plugin $ npm install aliyunoss-webpack-plugin --save-dev 在 webpack.prod.conf.js 中配置自己的路径和相应的 key new AliyunossWebpackPlugin(&#123; buildPath: __dirname + \"/build\", region: \"your region\", accessKeyId: \"your accessKeyId\", accessKeySecret: \"your accessKeySecret\", bucket: \"your bucket\", deleteAll: true, getObjectHeaders: function(filename) &#123; return &#123; \"Cache-Control\": \"max-age=2592000\" &#125;; &#125; &#125;); 五、部署项目 $ npm run build 至此，项目部署已完成，配置相应的域名即可访问。 书写完毕，如有欠缺，请多指教。","categories":[{"name":"技术整理","slug":"技术整理","permalink":"https://iamtaoxin.com/categories/%E6%8A%80%E6%9C%AF%E6%95%B4%E7%90%86/"}],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://iamtaoxin.com/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]},{"title":"leadcloud数据存储开发指南(四)－Js篇","date":"2016-08-01T14:20:46.000Z","path":"2016/08/01/leancloud-shu-ju-cun-chu-kai-fa-zhi-nan-4/","text":"leadcloud数据存储开发指南(四)－Js篇保存对象AV.Object 对象在保存时可以设置选项来快捷完成关联操作，可用的选项属性有： 选项 类型 说明 fetchWhenSave BOOL 对象成功保存后，自动返回该对象在云端的最新数据。用途请参考 更新计数器 query AV.Query 当 query 中的条件满足后对象才能成功保存，否则放弃保存，并返回错误码 305。 示例： new AV.Query(&#39;Wiki&#39;).first().then(function (data) &#123; var wiki &#x3D; data; var currentVersion &#x3D; wiki.get(&#39;version&#39;); wiki.set(&#39;version&#39;, currentVersion + 1); wiki.save(null, &#123; query: new AV.Query(&#39;Wiki&#39;).equalTo(&#39;version&#39;, currentVersion) &#125;).then(function (data) &#123; &#125;, function (error) &#123; if (error) &#123; throw error; &#125; &#125;); &#125;, function (error) &#123; if (error) &#123; throw error; &#125; &#125;); 获取对象每个被成功保存在云端的对象会有一个唯一的 Id 标识 id，因此获取对象的最基本的方法就是根据 id 来查询： var query &#x3D; new AV.Query(&#39;Todo&#39;); query.get(&#39;57328ca079bc44005c2472d0&#39;).then(function (data) &#123; &#x2F;&#x2F; 成功获得实例 &#x2F;&#x2F; data 就是 id 为 57328ca079bc44005c2472d0 的 Todo 对象实例 &#125;, function (error) &#123; &#x2F;&#x2F; 失败了 &#125;); 如果不想使用查询，还可以通过从本地构建一个 id，然后调用接口从云端把这个 id 的数据拉取到本地，示例代码如下: &#x2F;&#x2F; 第一个参数是 className，第二个参数是 objectId var todo &#x3D; AV.Object.createWithoutData(&#39;Todo&#39;, &#39;5745557f71cfe40068c6abe0&#39;); var title &#x3D; todo.get(&#39;title&#39;);&#x2F;&#x2F; 读取 title var content &#x3D; todo.get(&#39;content&#39;);&#x2F;&#x2F; 读取 content 获取 objectId每一次对象存储成功之后，云端都会返回 id，它是一个全局唯一的属性。 var todo &#x3D; new Todo(); todo.set(&#39;title&#39;, &#39;工程师周会&#39;); todo.set(&#39;content&#39;, &#39;每周工程师会议，周一下午2点&#39;); todo.save().then(function (todo) &#123; &#x2F;&#x2F; 成功保存之后，执行其他逻辑 &#x2F;&#x2F; 获取 objectId var objectId &#x3D; todo.id; &#125;, function (error) &#123; &#x2F;&#x2F; 失败之后执行其他逻辑 console.log(error); &#125;);","categories":[{"name":"技术整理","slug":"技术整理","permalink":"https://iamtaoxin.com/categories/%E6%8A%80%E6%9C%AF%E6%95%B4%E7%90%86/"}],"tags":[{"name":"leancloud","slug":"leancloud","permalink":"https://iamtaoxin.com/tags/leancloud/"}]},{"title":"Js实现对象的深度拷贝","date":"2016-07-31T14:24:30.000Z","path":"2016/07/31/js-shi-xian-dui-xiang-de-shen-du-kao-bei/","text":"在前端页面中，有些时候数据的变化并没有驱动页面视图的变化，这个时候就需要深度拷贝，所以封装了一个使用原生JS深度的拷贝，代码如下： function deepCopy(oldObj) &#123; &#x2F;&#x2F; 定义一个新的空对象 let newObject &#x3D; &#123;&#125;; &#x2F;&#x2F; 判断原对象是否存在 if(oldObj)&#123; &#x2F;&#x2F; 判断原对象的类型 if (oldObj.constructor &#x3D;&#x3D;&#x3D; Object) &#123; newObject &#x3D; new oldObj.constructor(); &#125; else &#123; newObject &#x3D; new oldObj.constructor(oldObj.valueOf()); &#125; &#x2F;&#x2F; 遍历克隆原对象的属性 for (const key in oldObj) &#123; if (newObject[key] !&#x3D;&#x3D; oldObj[key]) &#123; if (typeof(oldObj[key]) &#x3D;&#x3D;&#x3D; &#39;object&#39;) &#123; &#x2F;&#x2F; 对象内部的子对象 newObject[key] &#x3D; deepCopy(oldObj[key]); &#125; else &#123; newObject[key] &#x3D; oldObj[key]; &#125; &#125; &#125; &#x2F;&#x2F; 克隆原对象的常用方法 newObject.toString &#x3D; oldObj.toString; newObject.valueOf &#x3D; oldObj.valueOf; return newObject; &#125; &#125;","categories":[{"name":"技术整理","slug":"技术整理","permalink":"https://iamtaoxin.com/categories/%E6%8A%80%E6%9C%AF%E6%95%B4%E7%90%86/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://iamtaoxin.com/tags/JavaScript/"}]},{"title":"Leancloud对象","date":"2016-07-29T14:47:31.000Z","path":"2016/07/29/leancloud-dui-xiang/","text":"leadcloud数据存储开发指南(三)－Js篇AV.Object 是 LeanStorage 对复杂对象的封装，每个 AV.Object 包含若干属性值对，也称键值对（key-value）。属性的值是与 JSON 格式兼容的数据。通过 REST API 保存对象需要将对象的数据通过 JSON 来编码。这个数据是无模式化的（Schema Free），这意味着你不需要提前标注每个对象上有哪些 key，你只需要随意设置 key-value 对就可以，云端会保存它。 数据类型：AV.Object 支持以下类型： &#x2F;&#x2F; 该语句应该只声明一次 var TestObject &#x3D; AV.Object.extend(&#39;DataTypeTest&#39;); var number &#x3D; 2014; var string &#x3D; &#39;famous film name is &#39; + number; var date &#x3D; new Date(); var array &#x3D; [string, number]; var object &#x3D; &#123; number: number, string: string &#125;; var testObject &#x3D; new TestObject(); testObject.set(&#39;testNumber&#39;, number); testObject.set(&#39;testString&#39;, string); testObject.set(&#39;testDate&#39;, date); testObject.set(&#39;testArray&#39;, array); testObject.set(&#39;testObject&#39;, object); testObject.set(&#39;testNull&#39;, null); testObject.save().then(function(testObject) &#123; &#x2F;&#x2F; 成功 &#125;, function(error) &#123; &#x2F;&#x2F; 失败 &#125;); 注：每个 AV.Object 的大小都不应超过 128 KB。如果需要储存更多的数据，建议使用 AV.File。 构建对象：构建一个AV.Object对象可以使用以下方式： &#x2F;&#x2F; AV.Object.extend(&#39;className&#39;) 所需的参数 className 则表示对应的表名 &#x2F;&#x2F; 声明一个类型 var Todo &#x3D; AV.Object.extend(&#39;Todo&#39;); 注：每个 id 必须有一个 Class 类名称，这样云端才知道它的数据归属于哪张数据表。 保存对象：现在我们保存一个 TodoFolder，它可以包含多个 Todo，类似于给行程按文件夹的方式分组。我们并不需要提前去后台创建这个名为 TodoFolder 的 Class 类，而仅需要执行如下代码，云端就会自动创建这个类： &#x2F;&#x2F; 声明类型 var TodoFolder &#x3D; AV.Object.extend(&#39;TodoFolder&#39;); &#x2F;&#x2F; 新建对象 var todoFolder &#x3D; new TodoFolder(); &#x2F;&#x2F; 设置名称 todoFolder.set(&#39;name&#39;,&#39;工作&#39;); &#x2F;&#x2F; 设置优先级 todoFolder.set(&#39;priority&#39;,1); todoFolder.save().then(function (todo) &#123; console.log(&#39;objectId is &#39; + todo.id); &#125;, function (error) &#123; console.log(error); &#125;); 创建完成后，打开 控制台 &gt; 存储，点开 TodoFolder 类，就可以看到刚才添加的数据。除了 name、priority（优先级）之外，其他字段都是数据表的内置属性。 内置属性 类型 描述 id String 该对象唯一的Id标识 ACL ACL 该对象的权限控制，实际上是一个 JSON 对象，控制台做了展现优化。 createdAt Date 该对象被创建的 UTC 时间，控制台做了针对当地时间的展现优化。 updatedAt Date 该对象最后一次被修改的时间 属性名也叫键或 key，必须是由字母、数字或下划线组成的字符串；自定义的属性名，不能以 __（双下划线）开头。属性值可以是字符串、数字、布尔值、数组或字典。 以下为系统保留字段，不能作为属性名来使用。 acl error pendingKeys ACL fetchWhenSave running className id updatedAt code isDataReady uuid createdAt keyValues description objectId 使用CQL语法保存对象 &#x2F;&#x2F; 执行 CQL 语句实现新增一个 TodoFolder 对象 AV.Query.doCloudQuery(&#39;insert into TodoFolder(name, priority) values(&quot;工作&quot;, 1)&#39;).then(function (data) &#123; &#x2F;&#x2F; data 中的 results 是本次查询返回的结果，AV.Object 实例列表 var results &#x3D; data.results; &#125;, function (error) &#123; &#x2F;&#x2F;查询失败，查看 error console.log(error); &#125;); leadcloud","categories":[{"name":"技术整理","slug":"技术整理","permalink":"https://iamtaoxin.com/categories/%E6%8A%80%E6%9C%AF%E6%95%B4%E7%90%86/"}],"tags":[{"name":"leancloud","slug":"leancloud","permalink":"https://iamtaoxin.com/tags/leancloud/"}]},{"title":"Leancloud开发指南2","date":"2016-07-28T12:23:57.000Z","path":"2016/07/28/leancloud-kai-fa-zhi-nan-2/","text":"leadcloud数据存储开发指南(二)－Js篇 初始化首先注册并登录leancloud,创建应用： 然后打开 控制台 / 设置 / 应用 Key：前端项目使用leadcloud javascript sdk，在页面加载的时候调用初始化函数： var APP_ID = 'apLrGX1xBjvsj3TROPuj41A6z2gasD-ZAFG'; var APP_KEY = 'pE0Y3fCPp01I1DBS4Nh4Gj2'; AV.init(&#123; appId: APP_ID, appKey: APP_KEY &#125;); 启用节点：默认为大陆节点，如需切换到其他节点，可在初始化函数中加入：region: 节点，如下： const APP_ID &#x3D; &#39;apLrGX1xBjvsj3TROPuj41A6z2gasD-ZAFG&#39;; const APP_KEY &#x3D; &#39;pE0Y3fCPp01I1DBS4Nh4Gj2&#39;; AV.init(&#123; appId, appKey, &#x2F;&#x2F; 启用美国节点 region: &#39;us&#39;, &#125;); 验证验证本地网络是否可以访问leadcloud服务器， ping api.leancloud.cn 如果网络正常则得到如下相应： PING api.leancloud.cn (120.132.49.239): 56 data bytes 64 bytes from 120.132.49.239: icmp_seq&#x3D;3 ttl&#x3D;49 time&#x3D;65.165 ms 64 bytes from 120.132.49.239: icmp_seq&#x3D;4 ttl&#x3D;49 time&#x3D;53.273 ms 64 bytes from 120.132.49.239: icmp_seq&#x3D;5 ttl&#x3D;49 time&#x3D;51.519 ms 64 bytes from 120.132.49.239: icmp_seq&#x3D;6 ttl&#x3D;49 time&#x3D;68.442 ms 然后在项目中编写测试代码： const TestObject &#x3D; AV.Object.extend(&#39;TestObject&#39;); const testObject &#x3D; new TestObject(); await testObject.save(&#123; words: &#39;Hello World!&#39; &#125;); alert(&#39;LeanCloud Rocks!&#39;); 可在 控制台 &gt; 存储 &gt; 数据 &gt; TestObject，中查看测试内容，至此，sdk安装完毕","categories":[],"tags":[{"name":"leancloud","slug":"leancloud","permalink":"https://iamtaoxin.com/tags/leancloud/"}]},{"title":"Leadcloud数据存储（一）-Javascript","date":"2016-07-27T14:06:34.000Z","path":"2016/07/27/leadcloud-shu-ju-cun-chu-1/","text":"安装sdk获取sdk包依赖管理工具安装npm安装# 存储服务 $ npm install leancloud-storage --save # 实时消息服务 $ npm install leancloud-realtime --save cnpm安装 $ npm install -g cnpm --registry&#x3D;http:&#x2F;&#x2F;r.cnpmjs.org 然后执行 # 存储服务 $ cnpm install leancloud-storage --save # 实时消息服务 $ cnpm install leancloud-realtime --save bower安装$ bower install leancloud-storage --save cdn加速&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn1.lncld.net&#x2F;static&#x2F;js&#x2F;av-min-1.2.1.js&quot;&gt;&lt;&#x2F;script&gt; TypeScript 支持通过 typings 工具安装首先需要安装 typings 命令行工具 npm install typings --global 然后执行如下命令： typings install leadcloud-jssdk --save ######直接引用d.ts文件typescript使用javascript SDK是通过定义文件夹来实现调用的，定义文件夹开源地址：typed-leancloud-jssdk 手动安装 参考地址javascript数据存储开发指南","categories":[{"name":"技术整理","slug":"技术整理","permalink":"https://iamtaoxin.com/categories/%E6%8A%80%E6%9C%AF%E6%95%B4%E7%90%86/"}],"tags":[{"name":"leancloud","slug":"leancloud","permalink":"https://iamtaoxin.com/tags/leancloud/"}]},{"title":"NexT内置标签的使用","date":"2016-07-23T09:46:26.000Z","path":"2016/07/23/next-nei-zhi-biao-qian-de-shi-yong/","text":"NexT内置标签的使用 文本居中使用方法HTML方式:&lt;blockquote class&#x3D;&quot;blockquote-center&quot;&gt;这个城市的灯火辉煌，与你无关&lt;&#x2F;blockquote&gt; 标签方式：&lt;!-- 标签 方式，要求版本在0.4.5或以上 --&gt; &#123;% centerquote %&#125; 这个城市的灯火辉煌，与你无关 &#123;% endcenterquote %&#125; &lt;!-- 别名 --&gt; &#123;% cq %&#125; 这个城市的灯火辉煌，与你无关 &#123;% endcq %&#125; 示例：文字解释：此标签将生成一个带上下分割线的引用，同时引用内文本将自动居中。 图片突破容器宽度限制使用方式HTML方式：&lt;!-- HTML方式: 直接在 Markdown 文件中编写 HTML 来调用 --&gt; &lt;!-- 其中 class&#x3D;&quot;full-image&quot; 是必须的 --&gt; &lt;img src&#x3D;&quot;&#x2F;image-url&quot; class&#x3D;&quot;full-image&quot; &#x2F;&gt; 标签方式：&lt;!-- 标签 方式，要求版本在0.4.5或以上 --&gt; &#123;% fullimage &#x2F;image-url, alt, title %&#125; &lt;!-- 别名 --&gt; &#123;% fi &#x2F;image-url, alt, title %&#125; 示例：文字解释：当使用此标签引用图片时，图片将自动扩大 26%，并突破文章容器的宽度。 此标签使用于需要突出显示的图片, 图片的扩大与容器的偏差从视觉上提升图片的吸引力。","categories":[{"name":"技术整理","slug":"技术整理","permalink":"https://iamtaoxin.com/categories/%E6%8A%80%E6%9C%AF%E6%95%B4%E7%90%86/"}],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://iamtaoxin.com/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]},{"title":"NexT主题配置","date":"2016-07-18T15:10:48.000Z","path":"2016/07/18/next-zhu-ti-pei-zhi/","text":"NexT主题配置 ###添加「标签」页面 新建页面$ cd your-hexo-site $ hexo new page tags 设置页面类型编辑之前心间的标签页面，内容如下： title: 标签 date: 2014-12-22 12:39:04 type: &quot;tags&quot; --- 修改菜单编辑 主题配置文件 themes/_config.yml，内容如下： menu: home: &#x2F; archives: &#x2F;archives tags: &#x2F;tags ###添加「分类」页面 设置步骤同 设置标签步骤设置代码高亮主题编辑 主题配置文件 themes/_config.yml，内容如下： highlight_theme: normal 侧栏社交链接编辑 主题配置文件 themes/_config.yml 设置链接# Social links social: GitHub: https:&#x2F;&#x2F;github.com&#x2F;taosin 微博: http:&#x2F;&#x2F;www.weibo.com&#x2F;p&#x2F;1005055164097015&#x2F;home?from&#x3D;page_100505&amp;mod&#x3D;TAB&amp;is_all&#x3D;1#place # 等等 设置图标# Social Icons social_icons: enable: true # Icon Mappings GitHub: github Twitter: twitter 微博: weibo 设置打赏功能编辑 主题配置文件 themes/_config.yml reward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！ wechatpay: http:&#x2F;&#x2F;7xs43y.com1.z0.glb.clouddn.com&#x2F;u&#x3D;1421062774,389829371&amp;fm&#x3D;21&amp;gp&#x3D;0.jpg alipay: http:&#x2F;&#x2F;7xs43y.com1.z0.glb.clouddn.com&#x2F;u&#x3D;1421062774,389829371&amp;fm&#x3D;21&amp;gp&#x3D;0.jpg 设置友情链接编辑 主题配置文件 themes/_config.yml # title links_title: Links links: MacTalk: http:&#x2F;&#x2F;macshuo.com&#x2F; Title: http:&#x2F;&#x2F;example.com&#x2F; 腾讯公益404页面在themes/source目录下新建404页面，内容如下： &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv&#x3D;&quot;content-type&quot; content&#x3D;&quot;text&#x2F;html;charset&#x3D;utf-8;&quot;&#x2F;&gt; &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge,chrome&#x3D;1&quot; &#x2F;&gt; &lt;meta name&#x3D;&quot;robots&quot; content&#x3D;&quot;all&quot; &#x2F;&gt; &lt;meta name&#x3D;&quot;robots&quot; content&#x3D;&quot;index,follow&quot;&#x2F;&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;http:&#x2F;&#x2F;www.qq.com&#x2F;404&#x2F;search_children.js&quot; charset&#x3D;&quot;utf-8&quot; homePageUrl&#x3D;&quot;your site url &quot; homePageName&#x3D;&quot;回到我的主页&quot;&gt; &lt;&#x2F;script&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; 站点建立时间编辑 主题配置文件 themes/_config.yml since: 2013 注：本文参考NexT官方文档，如需了解详细，请访问NexT官网。","categories":[{"name":"技术整理","slug":"技术整理","permalink":"https://iamtaoxin.com/categories/%E6%8A%80%E6%9C%AF%E6%95%B4%E7%90%86/"}],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://iamtaoxin.com/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]},{"title":"hexo使用NexT主题","date":"2016-07-17T10:52:28.000Z","path":"2016/07/17/hexo-shi-yong-next-zhu-ti/","text":"hexo与NexT主题关于NexTNexT 主旨在于简洁优雅且易于使用，所以首先要尽量确保 NexT 的简洁易用性，github地址：https://github.com/iissnan/hexo-theme-next。 使用NExT下载主题进入到目标目录，使用git checkout代码： $ git clone https:&#x2F;&#x2F;github.com&#x2F;iissnan&#x2F;hexo-theme-next themes&#x2F;next 启用主题打开配置文件_config.yml修改theme字段 theme:next 验证主题hexo s --debug 访问浏览器， http://localhost:4000 主题设定Next共有三种外观： Muse, Mist , Piscec,在tmemes\\next_config.yml中进行更改 #scheme: Muse #scheme: Mist scheme: Pisces 设置语言编辑站点配置文件，设置所需语言，|语言 | 代码 | 设定示例|English | en | language: en简体中文 |zh-Hans |language: zh-Hans繁體中文 |zh-hk 或者 zh-tw | language: zh-hk 设置菜单menu: home: &#x2F; archives: &#x2F;archives #about: &#x2F;about #categories: &#x2F;categories tags: &#x2F;tags #commonweal: &#x2F;404.html 设置头像编辑 站点配置文件， 新增字段 avatar， 值设置成头像的链接地址eg: avatar: http://example.com/avtar.png","categories":[{"name":"技术整理","slug":"技术整理","permalink":"https://iamtaoxin.com/categories/%E6%8A%80%E6%9C%AF%E6%95%B4%E7%90%86/"}],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://iamtaoxin.com/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]},{"title":"Hexo使用初体验","date":"2016-07-17T07:52:28.000Z","path":"2016/07/17/hexo-shi-yong-chu-ti-yan/","text":"hexo初体验hexo终于还是搭好了，分享一些踩坑经验安装Hexo首先在本地创建目标目录，使用下面命令安装hexomkdir hexo &amp; cd hexo sudo npm install -g hexo hexo初始化hexo init 生成静态页面 hexo generate（hexo g 等同于 hexo generate） 启动hexohexo server (hexo s 等同于 hexo server) 浏览器地址栏输入http://localhost:4000 ,即可浏览页面，此时hexo已经安装成功。 安装前准备NodeGitGithub帐号","categories":[{"name":"技术整理","slug":"技术整理","permalink":"https://iamtaoxin.com/categories/%E6%8A%80%E6%9C%AF%E6%95%B4%E7%90%86/"}],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://iamtaoxin.com/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]}]